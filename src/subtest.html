<html>
<head>
<script type="text/javascript">

var p = [
	[0, 0, 0],
	[4, 0, 0],
	[8, 4, 0],
	[11, 5, 0]
];

/*
 * Loop to calculate extent of points array.
 * In actual program, xy vectors are projected
 * from geographic lat/lon input coordinates.
 */
function get_xyz_points(points) {
	
	var p = [];
	
	// get xyz coordinates
	var xyz1 = points[0];
	
	var minx = xyz1[0];
	var maxx = xyz1[0];
	var miny = xyz1[1];
	var maxy = xyz1[1];
	var minz = xyz1[2];
	var maxz = xyz1[2];
	p.push(xyz1);
	
	for (var i = 1; i < points.length; i++) {
		
		// get xyz coordinates
		var xyz = points[i];
		
		if (xyz[0] < minx) {
			minx = xyz[0];
		}
		
		if (xyz[0] > maxx) {
			maxx = xyz[0];
		}
		
		if (xyz[1] < miny) {
			miny = xyz[1];
		}
		
		if (xyz[1] > maxy) {
			maxy = xyz[1];
		}
		
		if (xyz[2] < minz) {
			minz = xyz[2];
		}
		
		if (xyz[2] > maxz) {
			maxz = xyz[2];
		}
		
		p.push(xyz);
	}
	
	var xextent = maxx - minx;
	var yextent = maxy - miny;
	var zextent = maxz - minz;
	
	var xoffset = -1/2 * (minx + maxx);
	var yoffset = -1/2 * (miny + maxy);
	
	
	return p;
}

/*
 * Given a point array and index of a point,
 * return the angle of the vector from that point
 * to the next. (2D) (If the index is to the last point,
 * return the preceding segment's angle. Point array
 * should have at least 2 points!)
 */
function segment_angle(p, i) {
	
	// in case of final point, repeat last segment angle
	if (i + 1 == p.length) {
		return segment_angle(p, i - 1);
	}
	
	// 2D coordinates of this point and the next
	var ix = p[i][0],
		iy = p[i][1],
		jx = p[i + 1][0],
		jy = p[i + 1][1],
		
	// Vector components of segment from this to next
		dx = jx - ix,
		dy = jy - iy,
		
	// Angle of segment vector (radians ccw from x-axis)
		angle = Math.atan2(dy, dx);
	
	return angle;
}

/*
 * Return a pair of 2D points representing the joints
 * where the buffered paths around the actual segment
 * intersect - segment endpoints offset perpendicular
 * to segment by buffer distance, adjusted for tidy
 * intersection with adjacent segment's buffered path.
 */
function joint_points(p, i, absa, avga) {
	
	// the standard segment buffer width
	var buffer = 1;
	
	// distance from endpoint to segment buffer intersection
	var jointr = buffer/Math.cos(avga - absa),
	
	// joint coordinates (endpoint offset at bisect angle by jointr)
		lx = p[i][0] + jointr * Math.cos(avga + Math.PI/2),
		ly = p[i][1] + jointr * Math.sin(avga + Math.PI/2),
		rx = p[i][0] + jointr * Math.cos(avga - Math.PI/2),
		ry = p[i][1] + jointr * Math.sin(avga - Math.PI/2);
	
	return [[lx, ly], [rx, ry]];
}

/*
 * Given a point array p with at least two points, loop
 * through each segment (pair of points). In each iteration
 * of the for loop, pj and pk are the 2D coordinates of the
 * corners of the quad representing a buffered path for
 * that segment; consecutive segments share endpoints.
 */
function process_path(p) {

	var a0 = segment_angle(p, 0),
		a1,
		ra = 0,
		ja = a0,
		pj = joint_points(p, 0, a0, ja),
		pk;
	
	for (var i = 1; i < p.length; i++) {
		
		a1 = segment_angle(p, i);
		ra = a1 - a0;
		ja = ra / 2 + a0;
		pk = joint_points(p, i, a1, ja);
		
		console.log(pj.toString(), pk.toString());
		
		a0 = a1;
		pj = pk;
	}
}

</script>
</head>
</html>
