(function(module){var _CSGDEBUG=false;function fnNumberSort(a,b){return a-b;}


var CSG=function(){this.polygons=[];this.properties=new CSG.Properties();this.isCanonicalized=true;this.isRetesselated=true;};CSG.defaultResolution2D=32;CSG.defaultResolution3D=12;CSG.fromPolygons=function(polygons){var csg=new CSG();csg.polygons=polygons;csg.isCanonicalized=false;csg.isRetesselated=false;return csg;};CSG.fromSlices=function(options){return(new CSG.Polygon.createFromPoints([[0,0,0],[1,0,0],[1,1,0],[0,1,0]])).solidFromSlices(options);};CSG.fromObject=function(obj){var polygons=obj.polygons.map(function(p){return CSG.Polygon.fromObject(p);});var csg=CSG.fromPolygons(polygons);csg=csg.canonicalized();return csg;};CSG.fromCompactBinary=function(bin){if(bin['class']!="CSG")throw new Error("Not a CSG");var planes=[],planeData=bin.planeData,numplanes=planeData.length/4,arrayindex=0,x,y,z,w,normal,plane;for(var planeindex=0;planeindex<numplanes;planeindex++){x=planeData[arrayindex++];y=planeData[arrayindex++];z=planeData[arrayindex++];w=planeData[arrayindex++];normal=CSG.Vector3D.Create(x,y,z);plane=new CSG.Plane(normal,w);planes.push(plane);}
var vertices=[],vertexData=bin.vertexData,numvertices=vertexData.length/3,pos,vertex;arrayindex=0;for(var vertexindex=0;vertexindex<numvertices;vertexindex++){x=vertexData[arrayindex++];y=vertexData[arrayindex++];z=vertexData[arrayindex++];pos=CSG.Vector3D.Create(x,y,z);vertex=new CSG.Vertex(pos);vertices.push(vertex);}
var shareds=bin.shared.map(function(shared){return CSG.Polygon.Shared.fromObject(shared);});var polygons=[],numpolygons=bin.numPolygons,numVerticesPerPolygon=bin.numVerticesPerPolygon,polygonVertices=bin.polygonVertices,polygonPlaneIndexes=bin.polygonPlaneIndexes,polygonSharedIndexes=bin.polygonSharedIndexes,numpolygonvertices,polygonvertices,shared,polygon;arrayindex=0;for(var polygonindex=0;polygonindex<numpolygons;polygonindex++){numpolygonvertices=numVerticesPerPolygon[polygonindex];polygonvertices=[];for(var i=0;i<numpolygonvertices;i++){polygonvertices.push(vertices[polygonVertices[arrayindex++]]);}
plane=planes[polygonPlaneIndexes[polygonindex]];shared=shareds[polygonSharedIndexes[polygonindex]];polygon=new CSG.Polygon(polygonvertices,shared,plane);polygons.push(polygon);}
var csg=CSG.fromPolygons(polygons);csg.isCanonicalized=true;csg.isRetesselated=true;return csg;};CSG.prototype={toPolygons:function(){return this.polygons;},

union:function(csg){var csgs;if(csg instanceof Array){csgs=csg;}else{csgs=[csg];}
var result=this;for(var i=0;i<csgs.length;i++){var islast=(i==(csgs.length-1));result=result.unionSub(csgs[i],islast,islast);}
return result;},unionSub:function(csg,retesselate,canonicalize){if(!this.mayOverlap(csg)){return this.unionForNonIntersecting(csg);}else{var a=new CSG.Tree(this.polygons);var b=new CSG.Tree(csg.polygons);a.clipTo(b,false); b.clipTo(a);b.invert();b.clipTo(a);b.invert();var newpolygons=a.allPolygons().concat(b.allPolygons());var result=CSG.fromPolygons(newpolygons);result.properties=this.properties._merge(csg.properties);if(retesselate)result=result.reTesselated();if(canonicalize)result=result.canonicalized();return result;}},
unionForNonIntersecting:function(csg){var newpolygons=this.polygons.concat(csg.polygons);var result=CSG.fromPolygons(newpolygons);result.properties=this.properties._merge(csg.properties);result.isCanonicalized=this.isCanonicalized&&csg.isCanonicalized;result.isRetesselated=this.isRetesselated&&csg.isRetesselated;return result;},

subtract:function(csg){var csgs;if(csg instanceof Array){csgs=csg;}else{csgs=[csg];}
var result=this;for(var i=0;i<csgs.length;i++){var islast=(i==(csgs.length-1));result=result.subtractSub(csgs[i],islast,islast);}
return result;},subtractSub:function(csg,retesselate,canonicalize){var a=new CSG.Tree(this.polygons);var b=new CSG.Tree(csg.polygons);a.invert();a.clipTo(b);b.clipTo(a,true);a.addPolygons(b.allPolygons());a.invert();var result=CSG.fromPolygons(a.allPolygons());result.properties=this.properties._merge(csg.properties);if(retesselate)result=result.reTesselated();if(canonicalize)result=result.canonicalized();return result;},

intersect:function(csg){var csgs;if(csg instanceof Array){csgs=csg;}else{csgs=[csg];}
var result=this;for(var i=0;i<csgs.length;i++){var islast=(i==(csgs.length-1));result=result.intersectSub(csgs[i],islast,islast);}
return result;},intersectSub:function(csg,retesselate,canonicalize){var a=new CSG.Tree(this.polygons);var b=new CSG.Tree(csg.polygons);a.invert();b.clipTo(a);b.invert();a.clipTo(b);b.clipTo(a);a.addPolygons(b.allPolygons());a.invert();var result=CSG.fromPolygons(a.allPolygons());result.properties=this.properties._merge(csg.properties);if(retesselate)result=result.reTesselated();if(canonicalize)result=result.canonicalized();return result;},
inverse:function(){var flippedpolygons=this.polygons.map(function(p){return p.flipped();});return CSG.fromPolygons(flippedpolygons);}, transform1:function(matrix4x4){var newpolygons=this.polygons.map(function(p){return p.transform(matrix4x4);});var result=CSG.fromPolygons(newpolygons);result.properties=this.properties._transform(matrix4x4);result.isRetesselated=this.isRetesselated;return result;},transform:function(matrix4x4){var ismirror=matrix4x4.isMirroring();var transformedvertices={};var transformedplanes={};var newpolygons=this.polygons.map(function(p){var newplane;var plane=p.plane;var planetag=plane.getTag();if(planetag in transformedplanes){newplane=transformedplanes[planetag];}else{newplane=plane.transform(matrix4x4);transformedplanes[planetag]=newplane;}
var newvertices=p.vertices.map(function(v){var newvertex;var vertextag=v.getTag();if(vertextag in transformedvertices){newvertex=transformedvertices[vertextag];}else{newvertex=v.transform(matrix4x4);transformedvertices[vertextag]=newvertex;}
return newvertex;});if(ismirror)newvertices.reverse();return new CSG.Polygon(newvertices,p.shared,newplane);});var result=CSG.fromPolygons(newpolygons);result.properties=this.properties._transform(matrix4x4);result.isRetesselated=this.isRetesselated;result.isCanonicalized=this.isCanonicalized;return result;},toStlString:function(){var result="solid csg.js\n";this.polygons.map(function(p){result+=p.toStlString();});result+="endsolid csg.js\n";return result;},toX3D:function(){


var materialPolygonLists={},vertexCoords=[], vertexTagToCoordIndexMap={};this.polygons.map(function(p){var red=0,green=0,blue=1; if(p.shared&&p.shared.color){red=p.shared.color[0];green=p.shared.color[1];blue=p.shared.color[2];}
var polygonVertexIndices=[],numvertices=p.vertices.length,vertex;for(var i=0;i<numvertices;i++){vertex=p.vertices[i];if(!(vertex.getTag()in vertexTagToCoordIndexMap)){vertexCoords.push(vertex.pos._x.toString()+" "+
vertex.pos._y.toString()+" "+
vertex.pos._z.toString());vertexTagToCoordIndexMap[vertex.getTag()]=vertexCoords.length-1;}
polygonVertexIndices.push(vertexTagToCoordIndexMap[vertex.getTag()]);}
var polygonString=polygonVertexIndices.join(" ");var colorString=red.toString()+" "+green.toString()+" "+blue.toString();if(!(colorString in materialPolygonLists)){materialPolygonLists[colorString]=[];} 
materialPolygonLists[colorString].push(polygonString);}); var docType=document.implementation.createDocumentType("X3D",'ISO//Web3D//DTD X3D 3.1//EN" "http://www.web3d.org/specifications/x3d-3.1.dtd',null);var exportDoc=document.implementation.createDocument(null,"X3D",docType);exportDoc.insertBefore(exportDoc.createProcessingInstruction('xml','version="1.0" encoding="UTF-8"'),exportDoc.doctype);var exportRoot=exportDoc.getElementsByTagName("X3D")[0];exportRoot.setAttribute("profile","Interchange");exportRoot.setAttribute("version","3.1");exportRoot.setAttribute("xsd:noNamespaceSchemaLocation","http://www.web3d.org/specifications/x3d-3.1.xsd");exportRoot.setAttribute("xmlns:xsd","http://www.w3.org/2001/XMLSchema-instance");var exportScene=exportDoc.createElement("Scene");exportRoot.appendChild(exportScene);var coordsMeshDefined=false;for(var colorString in materialPolygonLists){var polygonList=materialPolygonLists[colorString];var shape=exportDoc.createElement("Shape");exportScene.appendChild(shape);var appearance=exportDoc.createElement("Appearance");shape.appendChild(appearance);var material=exportDoc.createElement("Material");appearance.appendChild(material);material.setAttribute("diffuseColor",colorString);material.setAttribute("ambientIntensity","1.0");var ifs=exportDoc.createElement("IndexedFaceSet");shape.appendChild(ifs);ifs.setAttribute("solid","true");ifs.setAttribute("coordIndex",polygonList.join(" -1 ")+" -1");var coordinate=exportDoc.createElement("Coordinate");ifs.appendChild(coordinate);if(coordsMeshDefined){coordinate.setAttribute("USE","coords_mesh");}else{coordinate.setAttribute("DEF","coords_mesh");coordinate.setAttribute("point",vertexCoords.join(" "));coordsMeshDefined=true;}}
var x3dstring=(new XMLSerializer()).serializeToString(exportDoc);return new Blob([x3dstring],{type:"model/x3d+xml"});}, toStlBinary:function(){var buffer=new ArrayBuffer(4);var int32buffer=new Int32Array(buffer,0,1);var int8buffer=new Int8Array(buffer,0,4);int32buffer[0]=0x11223344;if(int8buffer[0]!=0x44){throw new Error("Binary STL output is currently only supported on little-endian (Intel) processors");}
var numtriangles=0;this.polygons.map(function(p){var numvertices=p.vertices.length;var thisnumtriangles=(numvertices>=3)?numvertices-2:0;numtriangles+=thisnumtriangles;});var headerarray=new Uint8Array(80);for(var i=0;i<80;i++){headerarray[i]=65;}
var ar1=new Uint32Array(1);ar1[0]=numtriangles;var allTrianglesBuffer=new ArrayBuffer(50*numtriangles);var allTrianglesBufferAsInt8=new Int8Array(allTrianglesBuffer);

var triangleBuffer=new ArrayBuffer(50);var triangleBufferAsInt8=new Int8Array(triangleBuffer);var triangleFloat32array=new Float32Array(triangleBuffer,0,12);var triangleUint16array=new Uint16Array(triangleBuffer,48,1);var byteoffset=0;this.polygons.map(function(p){var numvertices=p.vertices.length;for(var i=0;i<numvertices-2;i++){var normal=p.plane.normal;triangleFloat32array[0]=normal._x;triangleFloat32array[1]=normal._y;triangleFloat32array[2]=normal._z;var arindex=3;for(var v=0;v<3;v++){var vv=v+((v>0)?i:0);var vertexpos=p.vertices[vv].pos;triangleFloat32array[arindex++]=vertexpos._x;triangleFloat32array[arindex++]=vertexpos._y;triangleFloat32array[arindex++]=vertexpos._z;}
triangleUint16array[0]=0;allTrianglesBufferAsInt8.set(triangleBufferAsInt8,byteoffset);byteoffset+=50;}});return new Blob([headerarray.buffer,ar1.buffer,allTrianglesBuffer],{type:"application/sla"});},toString:function(){var result="CSG solid:\n";this.polygons.map(function(p){result+=p.toString();});return result;},
 expand:function(radius,resolution){var result=this.expandedShell(radius,resolution,true);result=result.reTesselated();result.properties=this.properties; return result;},
 contract:function(radius,resolution){var expandedshell=this.expandedShell(radius,resolution,false);var result=this.subtract(expandedshell);result=result.reTesselated();result.properties=this.properties; return result;},



 expandedShell:function(radius,resolution,unionWithThis){var csg=this.reTesselated();var result;if(unionWithThis){result=csg;}else{result=new CSG();}
csg.polygons.map(function(polygon){var extrudevector=polygon.plane.normal.unit().times(2*radius);var translatedpolygon=polygon.translate(extrudevector.times(-0.5));var extrudedface=translatedpolygon.extrude(extrudevector);result=result.unionSub(extrudedface,false,false);});

 
var vertexpairs={};csg.polygons.map(function(polygon){var numvertices=polygon.vertices.length;var prevvertex=polygon.vertices[numvertices-1];var prevvertextag=prevvertex.getTag();for(var i=0;i<numvertices;i++){var vertex=polygon.vertices[i];var vertextag=vertex.getTag();var vertextagpair;if(vertextag<prevvertextag){vertextagpair=vertextag+"-"+prevvertextag;}else{vertextagpair=prevvertextag+"-"+vertextag;}
var obj;if(vertextagpair in vertexpairs){obj=vertexpairs[vertextagpair];}else{obj={v1:prevvertex,v2:vertex,planenormals:[]};vertexpairs[vertextagpair]=obj;}
obj.planenormals.push(polygon.plane.normal);prevvertextag=vertextag;prevvertex=vertex;}});



for(var vertextagpair in vertexpairs){var vertexpair=vertexpairs[vertextagpair],startpoint=vertexpair.v1.pos,endpoint=vertexpair.v2.pos,zbase=endpoint.minus(startpoint).unit(),xbase=vertexpair.planenormals[0].unit(),ybase=xbase.cross(zbase),angles=[];for(var i=0;i<resolution;i++){angles.push(i*Math.PI*2/resolution);}
for(var i=0,iMax=vertexpair.planenormals.length;i<iMax;i++){var planenormal=vertexpair.planenormals[i],si=ybase.dot(planenormal),co=xbase.dot(planenormal),angle=Math.atan2(si,co);if(angle<0)angle+=Math.PI*2;angles.push(angle);angle=Math.atan2(-si,-co);if(angle<0)angle+=Math.PI*2;angles.push(angle);}
angles=angles.sort(fnNumberSort);var numangles=angles.length,prevp1,prevp2,startfacevertices=[],endfacevertices=[],polygons=[];for(var i=-1;i<numangles;i++){var angle=angles[(i<0)?(i+numangles):i],si=Math.sin(angle),co=Math.cos(angle),p=xbase.times(co*radius).plus(ybase.times(si*radius)),p1=startpoint.plus(p),p2=endpoint.plus(p),skip=false;if(i>=0){if(p1.distanceTo(prevp1)<1e-5){skip=true;}}
if(!skip){if(i>=0){startfacevertices.push(new CSG.Vertex(p1));endfacevertices.push(new CSG.Vertex(p2));var polygonvertices=[new CSG.Vertex(prevp2),new CSG.Vertex(p2),new CSG.Vertex(p1),new CSG.Vertex(prevp1)];var polygon=new CSG.Polygon(polygonvertices);polygons.push(polygon);}
prevp1=p1;prevp2=p2;}}
endfacevertices.reverse();polygons.push(new CSG.Polygon(startfacevertices));polygons.push(new CSG.Polygon(endfacevertices));var cylinder=CSG.fromPolygons(polygons);result=result.unionSub(cylinder,false,false);}
 
var vertexmap={};csg.polygons.map(function(polygon){polygon.vertices.map(function(vertex){var vertextag=vertex.getTag();var obj;if(vertextag in vertexmap){obj=vertexmap[vertextag];}else{obj={pos:vertex.pos,normals:[]};vertexmap[vertextag]=obj;}
obj.normals.push(polygon.plane.normal);});});

 for(var vertextag in vertexmap){var vertexobj=vertexmap[vertextag];var xaxis=vertexobj.normals[0].unit();var bestzaxis=null;var bestzaxisorthogonality=0;for(var i=1;i<vertexobj.normals.length;i++){var normal=vertexobj.normals[i].unit();var cross=xaxis.cross(normal);var crosslength=cross.length();if(crosslength>0.05){if(crosslength>bestzaxisorthogonality){bestzaxisorthogonality=crosslength;bestzaxis=normal;}}}
if(!bestzaxis){bestzaxis=xaxis.randomNonParallelVector();}
var yaxis=xaxis.cross(bestzaxis).unit();var zaxis=yaxis.cross(xaxis);var sphere=CSG.sphere({center:vertexobj.pos,radius:radius,resolution:resolution,axes:[xaxis,yaxis,zaxis]});result=result.unionSub(sphere,false,false);}
return result;},canonicalized:function(){if(this.isCanonicalized){return this;}else{var factory=new CSG.fuzzyCSGFactory();var result=factory.getCSG(this);result.isCanonicalized=true;result.isRetesselated=this.isRetesselated;result.properties=this.properties; return result;}},reTesselated:function(){if(this.isRetesselated){return this;}else{var csg=this;var polygonsPerPlane={};var isCanonicalized=csg.isCanonicalized;var fuzzyfactory=new CSG.fuzzyCSGFactory();csg.polygons.map(function(polygon){var plane=polygon.plane;var shared=polygon.shared;if(!isCanonicalized)
{
plane=fuzzyfactory.getPlane(plane);shared=fuzzyfactory.getPolygonShared(shared);}
var tag=plane.getTag()+"/"+shared.getTag();if(!(tag in polygonsPerPlane)){polygonsPerPlane[tag]=[polygon];}
else
{polygonsPerPlane[tag].push(polygon);}});var destpolygons=[];for(var planetag in polygonsPerPlane){var sourcepolygons=polygonsPerPlane[planetag];if(sourcepolygons.length<2){destpolygons=destpolygons.concat(sourcepolygons);}else{var retesselayedpolygons=[];CSG.reTesselateCoplanarPolygons(sourcepolygons,retesselayedpolygons);destpolygons=destpolygons.concat(retesselayedpolygons);}}
var result=CSG.fromPolygons(destpolygons);result.isRetesselated=true;result.properties=this.properties; return result;}},getBounds:function(){if(!this.cachedBoundingBox){var minpoint=new CSG.Vector3D(0,0,0);var maxpoint=new CSG.Vector3D(0,0,0);var polygons=this.polygons;var numpolygons=polygons.length;for(var i=0;i<numpolygons;i++){var polygon=polygons[i];var bounds=polygon.boundingBox();if(i===0){minpoint=bounds[0];maxpoint=bounds[1];}else{minpoint=minpoint.min(bounds[0]);maxpoint=maxpoint.max(bounds[1]);}}
this.cachedBoundingBox=[minpoint,maxpoint];}
return this.cachedBoundingBox;},
 mayOverlap:function(csg){if((this.polygons.length===0)||(csg.polygons.length===0)){return false;}else{var mybounds=this.getBounds();var otherbounds=csg.getBounds();if(mybounds[1].x<otherbounds[0].x)return false;if(mybounds[0].x>otherbounds[1].x)return false;if(mybounds[1].y<otherbounds[0].y)return false;if(mybounds[0].y>otherbounds[1].y)return false;if(mybounds[1].z<otherbounds[0].z)return false;if(mybounds[0].z>otherbounds[1].z)return false;return true;}}, cutByPlane:function(plane){if(this.polygons.length===0){return new CSG();}



var planecenter=plane.normal.times(plane.w);var maxdistance=0;this.polygons.map(function(polygon){polygon.vertices.map(function(vertex){var distance=vertex.pos.distanceToSquared(planecenter);if(distance>maxdistance)maxdistance=distance;});});maxdistance=Math.sqrt(maxdistance);maxdistance*=1.01;
var vertices=[];var orthobasis=new CSG.OrthoNormalBasis(plane);vertices.push(new CSG.Vertex(orthobasis.to3D(new CSG.Vector2D(maxdistance,-maxdistance))));vertices.push(new CSG.Vertex(orthobasis.to3D(new CSG.Vector2D(-maxdistance,-maxdistance))));vertices.push(new CSG.Vertex(orthobasis.to3D(new CSG.Vector2D(-maxdistance,maxdistance))));vertices.push(new CSG.Vertex(orthobasis.to3D(new CSG.Vector2D(maxdistance,maxdistance))));var polygon=new CSG.Polygon(vertices,null,plane.flipped());var cube=polygon.extrude(plane.normal.times(-maxdistance));var result=this.intersect(cube);result.properties=this.properties; return result;},





 connectTo:function(myConnector,otherConnector,mirror,normalrotation){var matrix=myConnector.getTransformationTo(otherConnector,mirror,normalrotation);return this.transform(matrix);},
setShared:function(shared){var polygons=this.polygons.map(function(p){return new CSG.Polygon(p.vertices,shared,p.plane);});var result=CSG.fromPolygons(polygons);result.properties=this.properties; result.isRetesselated=this.isRetesselated;result.isCanonicalized=this.isCanonicalized;return result;},setColor:function(red,green,blue){var newshared=new CSG.Polygon.Shared([red,green,blue]);return this.setShared(newshared);},toCompactBinary:function(){var csg=this.canonicalized(),numpolygons=csg.polygons.length,numpolygonvertices=0,numvertices=0,vertexmap={},vertices=[],numplanes=0,planemap={},polygonindex=0,planes=[],shareds=[],sharedmap={},numshared=0;
csg.polygons.map(function(p){p.vertices.map(function(v){++numpolygonvertices;var vertextag=v.getTag();if(!(vertextag in vertexmap)){vertexmap[vertextag]=numvertices++;vertices.push(v);}});var planetag=p.plane.getTag();if(!(planetag in planemap)){planemap[planetag]=numplanes++;planes.push(p.plane);}
var sharedtag=p.shared.getTag();if(!(sharedtag in sharedmap)){sharedmap[sharedtag]=numshared++;shareds.push(p.shared);}});var numVerticesPerPolygon=new Uint32Array(numpolygons),polygonSharedIndexes=new Uint32Array(numpolygons),polygonVertices=new Uint32Array(numpolygonvertices),polygonPlaneIndexes=new Uint32Array(numpolygons),vertexData=new Float64Array(numvertices*3),planeData=new Float64Array(numplanes*4),polygonVerticesIndex=0;for(var polygonindex=0;polygonindex<numpolygons;++polygonindex){var p=csg.polygons[polygonindex];numVerticesPerPolygon[polygonindex]=p.vertices.length;p.vertices.map(function(v){var vertextag=v.getTag();var vertexindex=vertexmap[vertextag];polygonVertices[polygonVerticesIndex++]=vertexindex;});var planetag=p.plane.getTag();var planeindex=planemap[planetag];polygonPlaneIndexes[polygonindex]=planeindex;var sharedtag=p.shared.getTag();var sharedindex=sharedmap[sharedtag];polygonSharedIndexes[polygonindex]=sharedindex;}
var verticesArrayIndex=0;vertices.map(function(v){var pos=v.pos;vertexData[verticesArrayIndex++]=pos._x;vertexData[verticesArrayIndex++]=pos._y;vertexData[verticesArrayIndex++]=pos._z;});var planesArrayIndex=0;planes.map(function(p){var normal=p.normal;planeData[planesArrayIndex++]=normal._x;planeData[planesArrayIndex++]=normal._y;planeData[planesArrayIndex++]=normal._z;planeData[planesArrayIndex++]=p.w;});var result={"class":"CSG",numPolygons:numpolygons,numVerticesPerPolygon:numVerticesPerPolygon,polygonPlaneIndexes:polygonPlaneIndexes,polygonSharedIndexes:polygonSharedIndexes,polygonVertices:polygonVertices,vertexData:vertexData,planeData:planeData,shared:shareds};return result;},
 toPointCloud:function(cuberadius){var csg=this.reTesselated();var result=new CSG();
 var vertexmap={};csg.polygons.map(function(polygon){polygon.vertices.map(function(vertex){vertexmap[vertex.getTag()]=vertex.pos;});});for(var vertextag in vertexmap){var pos=vertexmap[vertextag];var cube=CSG.cube({center:pos,radius:cuberadius});result=result.unionSub(cube,false,false);}
result=result.reTesselated();return result;}, getTransformationAndInverseTransformationToFlatLying:function(){if(this.polygons.length===0){return new CSG.Matrix4x4();}else{var csg=this.canonicalized();var planemap={};csg.polygons.map(function(polygon){planemap[polygon.plane.getTag()]=polygon.plane;});
var xvector=new CSG.Vector3D(1,0,0);var yvector=new CSG.Vector3D(0,1,0);var zvector=new CSG.Vector3D(0,0,1);var z0connectorx=new CSG.Connector([0,0,0],[0,0,-1],xvector);var z0connectory=new CSG.Connector([0,0,0],[0,0,-1],yvector);var isfirst=true;var minheight=0;var maxdotz=0;var besttransformation,bestinversetransformation;for(var planetag in planemap){var plane=planemap[planetag];var pointonplane=plane.normal.times(plane.w);var transformation,inversetransformation;
 var xorthogonality=plane.normal.cross(xvector).length();var yorthogonality=plane.normal.cross(yvector).length();if(xorthogonality>yorthogonality){var planeconnector=new CSG.Connector(pointonplane,plane.normal,xvector);transformation=planeconnector.getTransformationTo(z0connectorx,false,0);inversetransformation=z0connectorx.getTransformationTo(planeconnector,false,0);}else{var planeconnector=new CSG.Connector(pointonplane,plane.normal,yvector);transformation=planeconnector.getTransformationTo(z0connectory,false,0);inversetransformation=z0connectory.getTransformationTo(planeconnector,false,0);}
var transformedcsg=csg.transform(transformation);var dotz=-plane.normal.dot(zvector);var bounds=transformedcsg.getBounds();var zheight=bounds[1].z-bounds[0].z;var isbetter=isfirst;if(!isbetter){if(zheight<minheight){isbetter=true;}else if(zheight==minheight){if(dotz>maxdotz)isbetter=true;}}
if(isbetter){var translation=new CSG.Vector3D([-0.5*(bounds[1].x+bounds[0].x),-0.5*(bounds[1].y+bounds[0].y),-bounds[0].z]);transformation=transformation.multiply(CSG.Matrix4x4.translation(translation));inversetransformation=CSG.Matrix4x4.translation(translation.negated()).multiply(inversetransformation);minheight=zheight;maxdotz=dotz;besttransformation=transformation;bestinversetransformation=inversetransformation;}
isfirst=false;}
return[besttransformation,bestinversetransformation];}},getTransformationToFlatLying:function(){var result=this.getTransformationAndInverseTransformationToFlatLying();return result[0];},lieFlat:function(){var transformation=this.getTransformationToFlatLying();return this.transform(transformation);},

 projectToOrthoNormalBasis:function(orthobasis){var cags=[];this.polygons.map(function(polygon){var cag=polygon.projectToOrthoNormalBasis(orthobasis);if(cag.sides.length>0){cags.push(cag);}});var result=new CAG().union(cags);return result;},sectionCut:function(orthobasis){var plane1=orthobasis.plane;var plane2=orthobasis.plane.flipped();plane1=new CSG.Plane(plane1.normal,plane1.w+1e-4);plane2=new CSG.Plane(plane2.normal,plane2.w+1e-4);var cut3d=this.cutByPlane(plane1);cut3d=cut3d.cutByPlane(plane2);return cut3d.projectToOrthoNormalBasis(orthobasis);},fixTJunctions:function(){var csg=this.canonicalized();var sidemap={};for(var polygonindex=0;polygonindex<csg.polygons.length;polygonindex++){var polygon=csg.polygons[polygonindex];var numvertices=polygon.vertices.length;if(numvertices>=3)
{var vertex=polygon.vertices[0];var vertextag=vertex.getTag();for(var vertexindex=0;vertexindex<numvertices;vertexindex++){var nextvertexindex=vertexindex+1;if(nextvertexindex==numvertices)nextvertexindex=0;var nextvertex=polygon.vertices[nextvertexindex];var nextvertextag=nextvertex.getTag();var sidetag=vertextag+"/"+nextvertextag;var reversesidetag=nextvertextag+"/"+vertextag;if(reversesidetag in sidemap){var ar=sidemap[reversesidetag];ar.splice(-1,1);if(ar.length===0){delete sidemap[reversesidetag];}}else{var sideobj={vertex0:vertex,vertex1:nextvertex,polygonindex:polygonindex};if(!(sidetag in sidemap)){sidemap[sidetag]=[sideobj];}else{sidemap[sidetag].push(sideobj);}}
vertex=nextvertex;vertextag=nextvertextag;}}}
 
var vertextag2sidestart={};var vertextag2sideend={};var sidestocheck={};var sidemapisempty=true;for(var sidetag in sidemap){sidemapisempty=false;sidestocheck[sidetag]=true;sidemap[sidetag].map(function(sideobj){var starttag=sideobj.vertex0.getTag();var endtag=sideobj.vertex1.getTag();if(starttag in vertextag2sidestart){vertextag2sidestart[starttag].push(sidetag);}else{vertextag2sidestart[starttag]=[sidetag];}
if(endtag in vertextag2sideend){vertextag2sideend[endtag].push(sidetag);}else{vertextag2sideend[endtag]=[sidetag];}});}
if(!sidemapisempty){var polygons=csg.polygons.slice(0);var addSide=function(vertex0,vertex1,polygonindex){var starttag=vertex0.getTag();var endtag=vertex1.getTag();if(starttag==endtag)throw new Error("Assertion failed");var newsidetag=starttag+"/"+endtag;var reversesidetag=endtag+"/"+starttag;if(reversesidetag in sidemap){deleteSide(vertex1,vertex0,null);return null;}
var newsideobj={vertex0:vertex0,vertex1:vertex1,polygonindex:polygonindex};if(!(newsidetag in sidemap)){sidemap[newsidetag]=[newsideobj];}else{sidemap[newsidetag].push(newsideobj);}
if(starttag in vertextag2sidestart){vertextag2sidestart[starttag].push(newsidetag);}else{vertextag2sidestart[starttag]=[newsidetag];}
if(endtag in vertextag2sideend){vertextag2sideend[endtag].push(newsidetag);}else{vertextag2sideend[endtag]=[newsidetag];}
return newsidetag;}
var deleteSide=function(vertex0,vertex1,polygonindex){var starttag=vertex0.getTag();var endtag=vertex1.getTag();var sidetag=starttag+"/"+endtag;if(!(sidetag in sidemap))throw new Error("Assertion failed");var idx=-1;var sideobjs=sidemap[sidetag];for(var i=0;i<sideobjs.length;i++){var sideobj=sideobjs[i];if(sideobj.vertex0!=vertex0)continue;if(sideobj.vertex1!=vertex1)continue;if(polygonindex!==null){if(sideobj.polygonindex!=polygonindex)continue;}
idx=i;break;}
if(idx<0)throw new Error("Assertion failed");sideobjs.splice(idx,1);if(sideobjs.length===0){delete sidemap[sidetag];}
idx=vertextag2sidestart[starttag].indexOf(sidetag);if(idx<0)throw new Error("Assertion failed");vertextag2sidestart[starttag].splice(idx,1);if(vertextag2sidestart[starttag].length===0){delete vertextag2sidestart[starttag];}
idx=vertextag2sideend[endtag].indexOf(sidetag);if(idx<0)throw new Error("Assertion failed");vertextag2sideend[endtag].splice(idx,1);if(vertextag2sideend[endtag].length===0){delete vertextag2sideend[endtag];}}
while(true){var sidemapisempty=true;for(var sidetag in sidemap){sidemapisempty=false;sidestocheck[sidetag]=true;}
if(sidemapisempty)break;var donesomething=false;while(true){var sidetagtocheck=null;for(var sidetag in sidestocheck){sidetagtocheck=sidetag;break;}
if(sidetagtocheck===null)break;var donewithside=true;if(sidetagtocheck in sidemap){var sideobjs=sidemap[sidetagtocheck];if(sideobjs.length===0)throw new Error("Assertion failed");var sideobj=sideobjs[0];for(var directionindex=0;directionindex<2;directionindex++){var startvertex=(directionindex===0)?sideobj.vertex0:sideobj.vertex1;var endvertex=(directionindex===0)?sideobj.vertex1:sideobj.vertex0;var startvertextag=startvertex.getTag();var endvertextag=endvertex.getTag();var matchingsides=[];if(directionindex===0){if(startvertextag in vertextag2sideend){matchingsides=vertextag2sideend[startvertextag];}}else{if(startvertextag in vertextag2sidestart){matchingsides=vertextag2sidestart[startvertextag];}}
for(var matchingsideindex=0;matchingsideindex<matchingsides.length;matchingsideindex++){var matchingsidetag=matchingsides[matchingsideindex];var matchingside=sidemap[matchingsidetag][0];var matchingsidestartvertex=(directionindex===0)?matchingside.vertex0:matchingside.vertex1;var matchingsideendvertex=(directionindex===0)?matchingside.vertex1:matchingside.vertex0;var matchingsidestartvertextag=matchingsidestartvertex.getTag();var matchingsideendvertextag=matchingsideendvertex.getTag();if(matchingsideendvertextag!=startvertextag)throw new Error("Assertion failed");if(matchingsidestartvertextag==endvertextag){ deleteSide(startvertex,endvertex,null);deleteSide(endvertex,startvertex,null);donewithside=false;directionindex=2; donesomething=true;break;}else{var startpos=startvertex.pos;var endpos=endvertex.pos;var checkpos=matchingsidestartvertex.pos;var direction=checkpos.minus(startpos);var t=endpos.minus(startpos).dot(direction)/direction.dot(direction);if((t>0)&&(t<1)){var closestpoint=startpos.plus(direction.times(t));var distancesquared=closestpoint.distanceToSquared(endpos);if(distancesquared<1e-10){var polygonindex=matchingside.polygonindex;var polygon=polygons[polygonindex];var insertionvertextag=matchingside.vertex1.getTag();var insertionvertextagindex=-1;for(var i=0;i<polygon.vertices.length;i++){if(polygon.vertices[i].getTag()==insertionvertextag){insertionvertextagindex=i;break;}}
if(insertionvertextagindex<0)throw new Error("Assertion failed");var newvertices=polygon.vertices.slice(0);newvertices.splice(insertionvertextagindex,0,endvertex);var newpolygon=new CSG.Polygon(newvertices,polygon.shared );polygons[polygonindex]=newpolygon;deleteSide(matchingside.vertex0,matchingside.vertex1,polygonindex);var newsidetag1=addSide(matchingside.vertex0,endvertex,polygonindex);var newsidetag2=addSide(endvertex,matchingside.vertex1,polygonindex);if(newsidetag1!==null)sidestocheck[newsidetag1]=true;if(newsidetag2!==null)sidestocheck[newsidetag2]=true;donewithside=false;directionindex=2; donesomething=true;break;}
}
}
}
}
}
if(donewithside){delete sidestocheck[sidetag];}}
if(!donesomething)break;}
var newcsg=CSG.fromPolygons(polygons);newcsg.properties=csg.properties;newcsg.isCanonicalized=true;newcsg.isRetesselated=true;csg=newcsg;}
var sidemapisempty=true;for(var sidetag in sidemap){sidemapisempty=false;break;}
if(!sidemapisempty){throw new Error("!sidemapisempty");}
return csg;},toTriangles:function(){var polygons=[];this.polygons.forEach(function(poly){var firstVertex=poly.vertices[0];for(var i=poly.vertices.length-3;i>=0;i--){polygons.push(new CSG.Polygon([firstVertex,poly.vertices[i+1],poly.vertices[i+2]],poly.shared,poly.plane));}});return polygons;},getFeatures:function(features){if(!(features instanceof Array)){features=[features];}
var result=this.toTriangles().map(function(triPoly){return triPoly.getTetraFeatures(features);}).reduce(function(pv,v){return v.map(function(feat,i){return feat+(pv===0?0:pv[i]);});},0);return(result.length==1)?result[0]:result;}};
CSG.parseOption=function(options,optionname,defaultvalue){var result=defaultvalue;if(options){if(optionname in options){result=options[optionname];}}
return result;};
CSG.parseOptionAs3DVector=function(options,optionname,defaultvalue){var result=CSG.parseOption(options,optionname,defaultvalue);result=new CSG.Vector3D(result);return result;};CSG.parseOptionAs3DVectorList=function(options,optionname,defaultvalue){var result=CSG.parseOption(options,optionname,defaultvalue);return result.map(function(res){return new CSG.Vector3D(res);});};
CSG.parseOptionAs2DVector=function(options,optionname,defaultvalue){var result=CSG.parseOption(options,optionname,defaultvalue);result=new CSG.Vector2D(result);return result;};CSG.parseOptionAsFloat=function(options,optionname,defaultvalue){var result=CSG.parseOption(options,optionname,defaultvalue);if(typeof(result)=="string"){result=Number(result);}
if(isNaN(result)||typeof(result)!="number"){throw new Error("Parameter "+optionname+" should be a number");}
return result;};CSG.parseOptionAsInt=function(options,optionname,defaultvalue){var result=CSG.parseOption(options,optionname,defaultvalue);result=Number(Math.floor(result));if(isNaN(result)){throw new Error("Parameter "+optionname+" should be a number");}
return result;};CSG.parseOptionAsBool=function(options,optionname,defaultvalue){var result=CSG.parseOption(options,optionname,defaultvalue);if(typeof(result)=="string"){if(result=="true")result=true;else if(result=="false")result=false;else if(result==0)result=false;}
result=!!result;return result;};


CSG.cube=function(options){var c,r;options=options||{};if(('corner1'in options)||('corner2'in options))
{if(('center'in options)||('radius'in options))
{throw new Error("cube: should either give a radius and center parameter, or a corner1 and corner2 parameter")}
corner1=CSG.parseOptionAs3DVector(options,"corner1",[0,0,0]);corner2=CSG.parseOptionAs3DVector(options,"corner2",[1,1,1]);c=corner1.plus(corner2).times(0.5);r=corner2.minus(corner1).times(0.5);}
else
{c=CSG.parseOptionAs3DVector(options,"center",[0,0,0]);r=CSG.parseOptionAs3DVector(options,"radius",[1,1,1]);}
r=r.abs(); var result=CSG.fromPolygons([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[+1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,+1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,+1]]].map(function(info){var vertices=info[0].map(function(i){var pos=new CSG.Vector3D(c.x+r.x*(2*!!(i&1)-1),c.y+r.y*(2*!!(i&2)-1),c.z+r.z*(2*!!(i&4)-1));return new CSG.Vertex(pos);});return new CSG.Polygon(vertices,null );}));result.properties.cube=new CSG.Properties();result.properties.cube.center=new CSG.Vector3D(c);result.properties.cube.facecenters=[new CSG.Connector(new CSG.Vector3D([r.x,0,0]).plus(c),[1,0,0],[0,0,1]),new CSG.Connector(new CSG.Vector3D([-r.x,0,0]).plus(c),[-1,0,0],[0,0,1]),new CSG.Connector(new CSG.Vector3D([0,r.y,0]).plus(c),[0,1,0],[0,0,1]),new CSG.Connector(new CSG.Vector3D([0,-r.y,0]).plus(c),[0,-1,0],[0,0,1]),new CSG.Connector(new CSG.Vector3D([0,0,r.z]).plus(c),[0,0,1],[1,0,0]),new CSG.Connector(new CSG.Vector3D([0,0,-r.z]).plus(c),[0,0,-1],[1,0,0])];return result;};



CSG.sphere=function(options){options=options||{};var center=CSG.parseOptionAs3DVector(options,"center",[0,0,0]);var radius=CSG.parseOptionAsFloat(options,"radius",1);var resolution=CSG.parseOptionAsInt(options,"resolution",CSG.defaultResolution3D);var xvector,yvector,zvector;if('axes'in options){xvector=options.axes[0].unit().times(radius);yvector=options.axes[1].unit().times(radius);zvector=options.axes[2].unit().times(radius);}else{xvector=new CSG.Vector3D([1,0,0]).times(radius);yvector=new CSG.Vector3D([0,-1,0]).times(radius);zvector=new CSG.Vector3D([0,0,1]).times(radius);}
if(resolution<4)resolution=4;var qresolution=Math.round(resolution/4);var prevcylinderpoint;var polygons=[];for(var slice1=0;slice1<=resolution;slice1++){var angle=Math.PI*2.0*slice1/resolution;var cylinderpoint=xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));if(slice1>0){var vertices=[];var prevcospitch,prevsinpitch;for(var slice2=0;slice2<=qresolution;slice2++){var pitch=0.5*Math.PI*slice2/qresolution;var cospitch=Math.cos(pitch);var sinpitch=Math.sin(pitch);if(slice2>0){vertices=[];vertices.push(new CSG.Vertex(center.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));vertices.push(new CSG.Vertex(center.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));if(slice2<qresolution){vertices.push(new CSG.Vertex(center.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));}
vertices.push(new CSG.Vertex(center.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));polygons.push(new CSG.Polygon(vertices));vertices=[];vertices.push(new CSG.Vertex(center.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));vertices.push(new CSG.Vertex(center.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));if(slice2<qresolution){vertices.push(new CSG.Vertex(center.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));}
vertices.push(new CSG.Vertex(center.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));vertices.reverse();polygons.push(new CSG.Polygon(vertices));}
prevcospitch=cospitch;prevsinpitch=sinpitch;}}
prevcylinderpoint=cylinderpoint;}
var result=CSG.fromPolygons(polygons);result.properties.sphere=new CSG.Properties();result.properties.sphere.center=new CSG.Vector3D(center);result.properties.sphere.facepoint=center.plus(xvector);return result;};


CSG.cylinder=function(options){var s=CSG.parseOptionAs3DVector(options,"start",[0,-1,0]);var e=CSG.parseOptionAs3DVector(options,"end",[0,1,0]);var r=CSG.parseOptionAsFloat(options,"radius",1);var rEnd=CSG.parseOptionAsFloat(options,"radiusEnd",r);var rStart=CSG.parseOptionAsFloat(options,"radiusStart",r);if((rEnd<0)||(rStart<0)){throw new Error("Radius should be non-negative");}
if((rEnd===0)&&(rStart===0)){throw new Error("Either radiusStart or radiusEnd should be positive");}
var slices=CSG.parseOptionAsFloat(options,"resolution",CSG.defaultResolution2D);var ray=e.minus(s);var axisZ=ray.unit();var axisX=axisZ.randomNonParallelVector().unit();var axisY=axisX.cross(axisZ).unit();var start=new CSG.Vertex(s);var end=new CSG.Vertex(e);var polygons=[];function point(stack,slice,radius){var angle=slice*Math.PI*2;var out=axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));var pos=s.plus(ray.times(stack)).plus(out.times(radius));return new CSG.Vertex(pos);}
for(var i=0;i<slices;i++){var t0=i/slices,t1=(i+1)/slices;if(rEnd==rStart){polygons.push(new CSG.Polygon([start,point(0,t0,rEnd),point(0,t1,rEnd)]));polygons.push(new CSG.Polygon([point(0,t1,rEnd),point(0,t0,rEnd),point(1,t0,rEnd),point(1,t1,rEnd)]));polygons.push(new CSG.Polygon([end,point(1,t1,rEnd),point(1,t0,rEnd)]));}else{if(rStart>0){polygons.push(new CSG.Polygon([start,point(0,t0,rStart),point(0,t1,rStart)]));polygons.push(new CSG.Polygon([point(0,t0,rStart),point(1,t0,rEnd),point(0,t1,rStart)]));}
if(rEnd>0){polygons.push(new CSG.Polygon([end,point(1,t1,rEnd),point(1,t0,rEnd)]));polygons.push(new CSG.Polygon([point(1,t0,rEnd),point(1,t1,rEnd),point(0,t1,rStart)]));}}}
var result=CSG.fromPolygons(polygons);result.properties.cylinder=new CSG.Properties();result.properties.cylinder.start=new CSG.Connector(s,axisZ.negated(),axisX);result.properties.cylinder.end=new CSG.Connector(e,axisZ,axisX);result.properties.cylinder.facepoint=s.plus(axisX.times(rStart));return result;};



CSG.roundedCylinder=function(options){var p1=CSG.parseOptionAs3DVector(options,"start",[0,-1,0]);var p2=CSG.parseOptionAs3DVector(options,"end",[0,1,0]);var radius=CSG.parseOptionAsFloat(options,"radius",1);var direction=p2.minus(p1);var defaultnormal;if(Math.abs(direction.x)>Math.abs(direction.y)){defaultnormal=new CSG.Vector3D(0,1,0);}else{defaultnormal=new CSG.Vector3D(1,0,0);}
var normal=CSG.parseOptionAs3DVector(options,"normal",defaultnormal);var resolution=CSG.parseOptionAsFloat(options,"resolution",CSG.defaultResolution3D);if(resolution<4)resolution=4;var polygons=[];var qresolution=Math.floor(0.25*resolution);var length=direction.length();if(length<1e-10){return CSG.sphere({center:p1,radius:radius,resolution:resolution});}
var zvector=direction.unit().times(radius);var xvector=zvector.cross(normal).unit().times(radius);var yvector=xvector.cross(zvector).unit().times(radius);var prevcylinderpoint;for(var slice1=0;slice1<=resolution;slice1++){var angle=Math.PI*2.0*slice1/resolution;var cylinderpoint=xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));if(slice1>0){var vertices=[];vertices.push(new CSG.Vertex(p1.plus(cylinderpoint)));vertices.push(new CSG.Vertex(p1.plus(prevcylinderpoint)));vertices.push(new CSG.Vertex(p2.plus(prevcylinderpoint)));vertices.push(new CSG.Vertex(p2.plus(cylinderpoint)));polygons.push(new CSG.Polygon(vertices));var prevcospitch,prevsinpitch;for(var slice2=0;slice2<=qresolution;slice2++){var pitch=0.5*Math.PI*slice2/qresolution;var cospitch=Math.cos(pitch);var sinpitch=Math.sin(pitch);if(slice2>0){vertices=[];vertices.push(new CSG.Vertex(p1.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));vertices.push(new CSG.Vertex(p1.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));if(slice2<qresolution){vertices.push(new CSG.Vertex(p1.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));}
vertices.push(new CSG.Vertex(p1.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));polygons.push(new CSG.Polygon(vertices));vertices=[];vertices.push(new CSG.Vertex(p2.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));vertices.push(new CSG.Vertex(p2.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));if(slice2<qresolution){vertices.push(new CSG.Vertex(p2.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));}
vertices.push(new CSG.Vertex(p2.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));vertices.reverse();polygons.push(new CSG.Polygon(vertices));}
prevcospitch=cospitch;prevsinpitch=sinpitch;}}
prevcylinderpoint=cylinderpoint;}
var result=CSG.fromPolygons(polygons);var ray=zvector.unit();var axisX=xvector.unit();result.properties.roundedCylinder=new CSG.Properties();result.properties.roundedCylinder.start=new CSG.Connector(p1,ray.negated(),axisX);result.properties.roundedCylinder.end=new CSG.Connector(p2,ray,axisX);result.properties.roundedCylinder.facepoint=p1.plus(xvector);return result;};


CSG.roundedCube=function(options){var center,cuberadius;options=options||{};if(('corner1'in options)||('corner2'in options))
{if(('center'in options)||('radius'in options))
{throw new Error("roundedCube: should either give a radius and center parameter, or a corner1 and corner2 parameter")}
corner1=CSG.parseOptionAs3DVector(options,"corner1",[0,0,0]);corner2=CSG.parseOptionAs3DVector(options,"corner2",[1,1,1]);center=corner1.plus(corner2).times(0.5);cuberadius=corner2.minus(corner1).times(0.5);}
else
{center=CSG.parseOptionAs3DVector(options,"center",[0,0,0]);cuberadius=CSG.parseOptionAs3DVector(options,"radius",[1,1,1]);}
cuberadius=cuberadius.abs(); var resolution=CSG.parseOptionAsFloat(options,"resolution",CSG.defaultResolution3D);if(resolution<4)resolution=4;var roundradius=CSG.parseOptionAsFloat(options,"roundradius",0.2);var innercuberadius=cuberadius;innercuberadius=innercuberadius.minus(new CSG.Vector3D(roundradius));var result=CSG.cube({center:center,radius:[cuberadius.x,innercuberadius.y,innercuberadius.z]});result=result.unionSub(CSG.cube({center:center,radius:[innercuberadius.x,cuberadius.y,innercuberadius.z]}),false,false);result=result.unionSub(CSG.cube({center:center,radius:[innercuberadius.x,innercuberadius.y,cuberadius.z]}),false,false);for(var level=0;level<2;level++){var z=innercuberadius.z;if(level==1)z=-z;var p1=new CSG.Vector3D(innercuberadius.x,innercuberadius.y,z).plus(center);var p2=new CSG.Vector3D(innercuberadius.x,-innercuberadius.y,z).plus(center);var p3=new CSG.Vector3D(-innercuberadius.x,-innercuberadius.y,z).plus(center);var p4=new CSG.Vector3D(-innercuberadius.x,innercuberadius.y,z).plus(center);var sphere=CSG.sphere({center:p1,radius:roundradius,resolution:resolution});result=result.unionSub(sphere,false,false);sphere=CSG.sphere({center:p2,radius:roundradius,resolution:resolution});result=result.unionSub(sphere,false,false);sphere=CSG.sphere({center:p3,radius:roundradius,resolution:resolution});result=result.unionSub(sphere,false,false);sphere=CSG.sphere({center:p4,radius:roundradius,resolution:resolution});result=result.unionSub(sphere,false,true);var cylinder=CSG.cylinder({start:p1,end:p2,radius:roundradius,resolution:resolution});result=result.unionSub(cylinder,false,false);cylinder=CSG.cylinder({start:p2,end:p3,radius:roundradius,resolution:resolution});result=result.unionSub(cylinder,false,false);cylinder=CSG.cylinder({start:p3,end:p4,radius:roundradius,resolution:resolution});result=result.unionSub(cylinder,false,false);cylinder=CSG.cylinder({start:p4,end:p1,radius:roundradius,resolution:resolution});result=result.unionSub(cylinder,false,false);if(level===0){var d=new CSG.Vector3D(0,0,-2*z);cylinder=CSG.cylinder({start:p1,end:p1.plus(d),radius:roundradius,resolution:resolution});result=result.unionSub(cylinder);cylinder=CSG.cylinder({start:p2,end:p2.plus(d),radius:roundradius,resolution:resolution});result=result.unionSub(cylinder);cylinder=CSG.cylinder({start:p3,end:p3.plus(d),radius:roundradius,resolution:resolution});result=result.unionSub(cylinder);cylinder=CSG.cylinder({start:p4,end:p4.plus(d),radius:roundradius,resolution:resolution});result=result.unionSub(cylinder,false,true);}}
result=result.reTesselated();result.properties.roundedCube=new CSG.Properties();result.properties.roundedCube.center=new CSG.Vertex(center);result.properties.roundedCube.facecenters=[new CSG.Connector(new CSG.Vector3D([cuberadius.x,0,0]).plus(center),[1,0,0],[0,0,1]),new CSG.Connector(new CSG.Vector3D([-cuberadius.x,0,0]).plus(center),[-1,0,0],[0,0,1]),new CSG.Connector(new CSG.Vector3D([0,cuberadius.y,0]).plus(center),[0,1,0],[0,0,1]),new CSG.Connector(new CSG.Vector3D([0,-cuberadius.y,0]).plus(center),[0,-1,0],[0,0,1]),new CSG.Connector(new CSG.Vector3D([0,0,cuberadius.z]).plus(center),[0,0,1],[1,0,0]),new CSG.Connector(new CSG.Vector3D([0,0,-cuberadius.z]).plus(center),[0,0,-1],[1,0,0])];return result;};CSG.polyhedron=function(options){options=options||{};if(('points'in options)!==('faces'in options)){throw new Error("polyhedron needs 'points' and 'faces' arrays");}
var vertices=CSG.parseOptionAs3DVectorList(options,"points",[[1,1,0],[1,-1,0],[-1,-1,0],[-1,1,0],[0,0,1]]).map(function(pt){return new CSG.Vertex(pt);});var faces=CSG.parseOption(options,"faces",[[0,1,4],[1,2,4],[2,3,4],[3,0,4],[1,0,3],[2,1,3]])
.map(function(face){return[face[1],face[0],face[2]];});var polygons=faces.map(function(face){return new CSG.Polygon(face.map(function(idx){return vertices[idx];}));}); return CSG.fromPolygons(polygons);};CSG.IsFloat=function(n){return(!isNaN(n))||(n===Infinity)||(n===-Infinity);};
CSG.solve2Linear=function(a,b,c,d,u,v){var det=a*d-b*c;var invdet=1.0/det;var x=u*d-b*v;var y=-u*c+a*v;x*=invdet;y*=invdet;return[x,y];};

CSG.Vector3D=function(x,y,z){if(arguments.length==3){this._x=parseFloat(x);this._y=parseFloat(y);this._z=parseFloat(z);}else if(arguments.length==2){this._x=parseFloat(x);this._y=parseFloat(y);this._z=0;}else{var ok=true;if(arguments.length==1){if(typeof(x)=="object"){if(x instanceof CSG.Vector3D){this._x=x._x;this._y=x._y;this._z=x._z;}else if(x instanceof CSG.Vector2D){this._x=x._x;this._y=x._y;this._z=0;}else if(x instanceof Array){if((x.length<2)||(x.length>3)){ok=false;}else{this._x=parseFloat(x[0]);this._y=parseFloat(x[1]);if(x.length==3){this._z=parseFloat(x[2]);}else{this._z=0;}}}else if(('x'in x)&&('y'in x)){this._x=parseFloat(x.x);this._y=parseFloat(x.y);if('z'in x){this._z=parseFloat(x.z);}else{this._z=0;}}else ok=false;}else{var v=parseFloat(x);this._x=v;this._y=v;this._z=v;}}else ok=false;if(ok){if((!CSG.IsFloat(this._x))||(!CSG.IsFloat(this._y))||(!CSG.IsFloat(this._z)))ok=false;}
if(!ok){throw new Error("wrong arguments");}}};
CSG.Vector3D.Create=function(x,y,z){var result=Object.create(CSG.Vector3D.prototype);result._x=x;result._y=y;result._z=z;return result;};CSG.Vector3D.prototype={get x(){return this._x;},get y(){return this._y;},get z(){return this._z;},set x(v){throw new Error("Vector3D is immutable");},set y(v){throw new Error("Vector3D is immutable");},set z(v){throw new Error("Vector3D is immutable");},clone:function(){return CSG.Vector3D.Create(this._x,this._y,this._z);},negated:function(){return CSG.Vector3D.Create(-this._x,-this._y,-this._z);},abs:function(){return CSG.Vector3D.Create(Math.abs(this._x),Math.abs(this._y),Math.abs(this._z));},plus:function(a){return CSG.Vector3D.Create(this._x+a._x,this._y+a._y,this._z+a._z);},minus:function(a){return CSG.Vector3D.Create(this._x-a._x,this._y-a._y,this._z-a._z);},times:function(a){return CSG.Vector3D.Create(this._x*a,this._y*a,this._z*a);},dividedBy:function(a){return CSG.Vector3D.Create(this._x/a,this._y/a,this._z/a);},dot:function(a){return this._x*a._x+this._y*a._y+this._z*a._z;},lerp:function(a,t){return this.plus(a.minus(this).times(t));},lengthSquared:function(){return this.dot(this);},length:function(){return Math.sqrt(this.lengthSquared());},unit:function(){return this.dividedBy(this.length());},cross:function(a){return CSG.Vector3D.Create(this._y*a._z-this._z*a._y,this._z*a._x-this._x*a._z,this._x*a._y-this._y*a._x);},distanceTo:function(a){return this.minus(a).length();},distanceToSquared:function(a){return this.minus(a).lengthSquared();},equals:function(a){return(this._x==a._x)&&(this._y==a._y)&&(this._z==a._z);}, 
multiply4x4:function(matrix4x4){return matrix4x4.leftMultiply1x3Vector(this);},transform:function(matrix4x4){return matrix4x4.leftMultiply1x3Vector(this);},toStlString:function(){return this._x+" "+this._y+" "+this._z;},toString:function(){return"("+this._x.toFixed(2)+", "+this._y.toFixed(2)+", "+this._z.toFixed(2)+")";}, randomNonParallelVector:function(){var abs=this.abs();if((abs._x<=abs._y)&&(abs._x<=abs._z)){return CSG.Vector3D.Create(1,0,0);}else if((abs._y<=abs._x)&&(abs._y<=abs._z)){return CSG.Vector3D.Create(0,1,0);}else{return CSG.Vector3D.Create(0,0,1);}},min:function(p){return CSG.Vector3D.Create(Math.min(this._x,p._x),Math.min(this._y,p._y),Math.min(this._z,p._z));},max:function(p){return CSG.Vector3D.Create(Math.max(this._x,p._x),Math.max(this._y,p._y),Math.max(this._z,p._z));}};




CSG.Vertex=function(pos){this.pos=pos;};CSG.Vertex.fromObject=function(obj){var pos=new CSG.Vector3D(obj.pos);return new CSG.Vertex(pos);};CSG.Vertex.prototype={
flipped:function(){return this;},getTag:function(){var result=this.tag;if(!result){result=CSG.getTag();this.tag=result;}
return result;},

interpolate:function(other,t){var newpos=this.pos.lerp(other.pos,t);return new CSG.Vertex(newpos);}, transform:function(matrix4x4){var newpos=this.pos.multiply4x4(matrix4x4);return new CSG.Vertex(newpos);},toStlString:function(){return"vertex "+this.pos.toStlString()+"\n";},toString:function(){return this.pos.toString();}};
CSG.Plane=function(normal,w){this.normal=normal;this.w=w;};CSG.Plane.fromObject=function(obj){var normal=new CSG.Vector3D(obj.normal);var w=parseFloat(obj.w);return new CSG.Plane(normal,w);};
CSG.Plane.EPSILON=1e-5;CSG.Plane.fromVector3Ds=function(a,b,c){var n=b.minus(a).cross(c.minus(a)).unit();return new CSG.Plane(n,n.dot(a));};
CSG.Plane.anyPlaneFromVector3Ds=function(a,b,c){var v1=b.minus(a);var v2=c.minus(a);if(v1.length()<1e-5){v1=v2.randomNonParallelVector();}
if(v2.length()<1e-5){v2=v1.randomNonParallelVector();}
var normal=v1.cross(v2);if(normal.length()<1e-5){v2=v1.randomNonParallelVector();normal=v1.cross(v2);}
normal=normal.unit();return new CSG.Plane(normal,normal.dot(a));};CSG.Plane.fromPoints=function(a,b,c){a=new CSG.Vector3D(a);b=new CSG.Vector3D(b);c=new CSG.Vector3D(c);return CSG.Plane.fromVector3Ds(a,b,c);};CSG.Plane.fromNormalAndPoint=function(normal,point){normal=new CSG.Vector3D(normal);point=new CSG.Vector3D(point);normal=normal.unit();var w=point.dot(normal);return new CSG.Plane(normal,w);};CSG.Plane.prototype={flipped:function(){return new CSG.Plane(this.normal.negated(),-this.w);},getTag:function(){var result=this.tag;if(!result){result=CSG.getTag();this.tag=result;}
return result;},equals:function(n){return this.normal.equals(n.normal)&&this.w==n.w;},transform:function(matrix4x4){var ismirror=matrix4x4.isMirroring();var r=this.normal.randomNonParallelVector();var u=this.normal.cross(r);var v=this.normal.cross(u);var point1=this.normal.times(this.w);var point2=point1.plus(u);var point3=point1.plus(v);point1=point1.multiply4x4(matrix4x4);point2=point2.multiply4x4(matrix4x4);point3=point3.multiply4x4(matrix4x4);var newplane=CSG.Plane.fromVector3Ds(point1,point2,point3);if(ismirror){
newplane=newplane.flipped();}
return newplane;},





 splitPolygon:function(polygon){var result={type:null,front:null,back:null};var planenormal=this.normal;var vertices=polygon.vertices;var numvertices=vertices.length;if(polygon.plane.equals(this)){result.type=0;}else{var EPS=CSG.Plane.EPSILON;var thisw=this.w;var hasfront=false;var hasback=false;var vertexIsBack=[];var MINEPS=-EPS;for(var i=0;i<numvertices;i++){var t=planenormal.dot(vertices[i].pos)-thisw;var isback=(t<0);vertexIsBack.push(isback);if(t>EPS)hasfront=true;if(t<MINEPS)hasback=true;}
if((!hasfront)&&(!hasback)){ var t=planenormal.dot(polygon.plane.normal);result.type=(t>=0)?0:1;}else if(!hasback){result.type=2;}else if(!hasfront){result.type=3;}else{ result.type=4;var frontvertices=[],backvertices=[];var isback=vertexIsBack[0];for(var vertexindex=0;vertexindex<numvertices;vertexindex++){var vertex=vertices[vertexindex];var nextvertexindex=vertexindex+1;if(nextvertexindex>=numvertices)nextvertexindex=0;var nextisback=vertexIsBack[nextvertexindex];if(isback==nextisback){if(isback){backvertices.push(vertex);}else{frontvertices.push(vertex);}}else{var point=vertex.pos;var nextpoint=vertices[nextvertexindex].pos;var intersectionpoint=this.splitLineBetweenPoints(point,nextpoint);var intersectionvertex=new CSG.Vertex(intersectionpoint);if(isback){backvertices.push(vertex);backvertices.push(intersectionvertex);frontvertices.push(intersectionvertex);}else{frontvertices.push(vertex);frontvertices.push(intersectionvertex);backvertices.push(intersectionvertex);}}
isback=nextisback;}

var EPS_SQUARED=CSG.Plane.EPSILON*CSG.Plane.EPSILON;if(backvertices.length>=3){var prevvertex=backvertices[backvertices.length-1];for(var vertexindex=0;vertexindex<backvertices.length;vertexindex++){var vertex=backvertices[vertexindex];if(vertex.pos.distanceToSquared(prevvertex.pos)<EPS_SQUARED){backvertices.splice(vertexindex,1);vertexindex--;}
prevvertex=vertex;}}
if(frontvertices.length>=3){var prevvertex=frontvertices[frontvertices.length-1];for(var vertexindex=0;vertexindex<frontvertices.length;vertexindex++){var vertex=frontvertices[vertexindex];if(vertex.pos.distanceToSquared(prevvertex.pos)<EPS_SQUARED){frontvertices.splice(vertexindex,1);vertexindex--;}
prevvertex=vertex;}}
if(frontvertices.length>=3){result.front=new CSG.Polygon(frontvertices,polygon.shared,polygon.plane);}
if(backvertices.length>=3){result.back=new CSG.Polygon(backvertices,polygon.shared,polygon.plane);}}}
return result;},
 splitLineBetweenPoints:function(p1,p2){var direction=p2.minus(p1);var labda=(this.w-this.normal.dot(p1))/this.normal.dot(direction);if(isNaN(labda))labda=0;if(labda>1)labda=1;if(labda<0)labda=0;var result=p1.plus(direction.times(labda));return result;}, intersectWithLine:function(line3d){return line3d.intersectWithPlane(this);}, intersectWithPlane:function(plane){return CSG.Line3D.fromPlanes(this,plane);},signedDistanceToPoint:function(point){var t=this.normal.dot(point)-this.w;return t;},toString:function(){return"[normal: "+this.normal.toString()+", w: "+this.w+"]";},mirrorPoint:function(point3d){var distance=this.signedDistanceToPoint(point3d);var mirrored=point3d.minus(this.normal.times(distance*2.0));return mirrored;}};





CSG.Polygon=function(vertices,shared,plane){this.vertices=vertices;if(!shared)shared=CSG.Polygon.defaultShared;this.shared=shared;if(arguments.length>=3){this.plane=plane;}else{this.plane=CSG.Plane.fromVector3Ds(vertices[0].pos,vertices[1].pos,vertices[2].pos);}
if(_CSGDEBUG){this.checkIfConvex();}};CSG.Polygon.fromObject=function(obj){var vertices=obj.vertices.map(function(v){return CSG.Vertex.fromObject(v);});var shared=CSG.Polygon.Shared.fromObject(obj.shared);var plane=CSG.Plane.fromObject(obj.plane);return new CSG.Polygon(vertices,shared,plane);};CSG.Polygon.prototype={checkIfConvex:function(){if(!CSG.Polygon.verticesConvex(this.vertices,this.plane.normal)){CSG.Polygon.verticesConvex(this.vertices,this.plane.normal);throw new Error("Not convex!");}},setColor:function(color){this.shared=new CSG.Polygon.Shared(color);return this;},_getSignedVolume:function(){return this.vertices[0].pos.dot(this.vertices[1].pos.cross(this.vertices[2].pos))/6;},_getArea:function(){return this.vertices[1].pos.minus(this.vertices[0].pos).cross(this.vertices[2].pos.minus(this.vertices[1].pos)).length()/2;},
 getTetraFeatures:function(features){var result=[];features.forEach(function(feature){if(feature=='volume'){result.push(this._getSignedVolume());}
else if(feature=='area'){result.push(this._getArea());}},this);return result;},
 extrude:function(offsetvector){var newpolygons=[];var polygon1=this;var direction=polygon1.plane.normal.dot(offsetvector);if(direction>0){polygon1=polygon1.flipped();}
newpolygons.push(polygon1);var polygon2=polygon1.translate(offsetvector);var numvertices=this.vertices.length;for(var i=0;i<numvertices;i++){var sidefacepoints=[];var nexti=(i<(numvertices-1))?i+1:0;sidefacepoints.push(polygon1.vertices[i].pos);sidefacepoints.push(polygon2.vertices[i].pos);sidefacepoints.push(polygon2.vertices[nexti].pos);sidefacepoints.push(polygon1.vertices[nexti].pos);var sidefacepolygon=CSG.Polygon.createFromPoints(sidefacepoints,this.shared);newpolygons.push(sidefacepolygon);}
polygon2=polygon2.flipped();newpolygons.push(polygon2);return CSG.fromPolygons(newpolygons);},translate:function(offset){return this.transform(CSG.Matrix4x4.translation(offset));}, boundingSphere:function(){if(!this.cachedBoundingSphere){var box=this.boundingBox();var middle=box[0].plus(box[1]).times(0.5);var radius3=box[1].minus(middle);var radius=radius3.length();this.cachedBoundingSphere=[middle,radius];}
return this.cachedBoundingSphere;},boundingBox:function(){if(!this.cachedBoundingBox){var minpoint,maxpoint;var vertices=this.vertices;var numvertices=vertices.length;if(numvertices===0){minpoint=new CSG.Vector3D(0,0,0);}else{minpoint=vertices[0].pos;}
maxpoint=minpoint;for(var i=1;i<numvertices;i++){var point=vertices[i].pos;minpoint=minpoint.min(point);maxpoint=maxpoint.max(point);}
this.cachedBoundingBox=[minpoint,maxpoint];}
return this.cachedBoundingBox;},flipped:function(){var newvertices=this.vertices.map(function(v){return v.flipped();});newvertices.reverse();var newplane=this.plane.flipped();return new CSG.Polygon(newvertices,this.shared,newplane);}, transform:function(matrix4x4){var newvertices=this.vertices.map(function(v){return v.transform(matrix4x4);});var newplane=this.plane.transform(matrix4x4);var scalefactor=matrix4x4.elements[0]*matrix4x4.elements[5]*matrix4x4.elements[10];if(scalefactor<0){
newvertices.reverse();}
return new CSG.Polygon(newvertices,this.shared,newplane);},toStlString:function(){var result="";if(this.vertices.length>=3)
{
var firstVertexStl=this.vertices[0].toStlString();for(var i=0;i<this.vertices.length-2;i++){result+="facet normal "+this.plane.normal.toStlString()+"\nouter loop\n";result+=firstVertexStl;result+=this.vertices[i+1].toStlString();result+=this.vertices[i+2].toStlString();result+="endloop\nendfacet\n";}}
return result;},toString:function(){var result="Polygon plane: "+this.plane.toString()+"\n";this.vertices.map(function(vertex){result+="  "+vertex.toString()+"\n";});return result;}, projectToOrthoNormalBasis:function(orthobasis){var points2d=this.vertices.map(function(vertex){return orthobasis.to2D(vertex.pos);});var result=CAG.fromPointsNoCheck(points2d);var area=result.area();if(Math.abs(area)<1e-5){
result=new CAG();}else if(area<0){result=result.flipped();}
return result;},solidFromSlices:function(options){var polygons=[],csg=null,prev=null,bottom=null,top=null,numSlices=2,bLoop=false,fnCallback,flipped=null;if(options){bLoop=Boolean(options['loop']);if(options.numslices)
numSlices=options.numslices;if(options.callback)
fnCallback=options.callback;}
if(!fnCallback){var square=new CSG.Polygon.createFromPoints([[0,0,0],[1,0,0],[1,1,0],[0,1,0]]);fnCallback=function(t,slice){return t==0||t==1?square.translate([0,0,t]):null;}}
for(var i=0,iMax=numSlices-1;i<=iMax;i++){csg=fnCallback.call(this,i/iMax,i);if(csg){if(!(csg instanceof CSG.Polygon)){throw new Error("CSG.Polygon.solidFromSlices callback error: CSG.Polygon expected");}
csg.checkIfConvex();if(prev){ if(flipped===null){ flipped=prev.plane.signedDistanceToPoint(csg.vertices[0].pos)<0;}
this._addWalls(polygons,prev,csg,flipped);}else{ bottom=csg;}
prev=csg;}
}
top=csg;if(bLoop){var bSameTopBottom=bottom.vertices.length==top.vertices.length&&bottom.vertices.every(function(v,index){return v.pos.equals(top.vertices[index].pos)}); if(!bSameTopBottom){this._addWalls(polygons,top,bottom,flipped);}
}else{
 polygons.unshift(flipped?bottom:bottom.flipped());polygons.push(flipped?top.flipped():top);}
return CSG.fromPolygons(polygons);},_addWalls:function(walls,bottom,top,bFlipped){var bottomPoints=bottom.vertices.slice(0), topPoints=top.vertices.slice(0), color=top.shared||null; if(!bottomPoints[0].pos.equals(bottomPoints[bottomPoints.length-1].pos)){bottomPoints.push(bottomPoints[0]);} 
if(!topPoints[0].pos.equals(topPoints[topPoints.length-1].pos)){topPoints.push(topPoints[0]);}
if(bFlipped){bottomPoints=bottomPoints.reverse();topPoints=topPoints.reverse();}
var iTopLen=topPoints.length-1,iBotLen=bottomPoints.length-1,iExtra=iTopLen-iBotLen, bMoreTops=iExtra>0,bMoreBottoms=iExtra<0;var aMin=[]; 
for(var i=Math.abs(iExtra);i>0;i--){aMin.push({len:Infinity,index:-1});}
var len;if(bMoreBottoms){for(var i=0;i<iBotLen;i++){len=bottomPoints[i].pos.distanceToSquared(bottomPoints[i+1].pos); for(var j=aMin.length-1;j>=0;j--){if(aMin[j].len>len){aMin[j].len=len;aMin.index=j;break;}}
}}else if(bMoreTops){for(var i=0;i<iTopLen;i++){len=topPoints[i].pos.distanceToSquared(topPoints[i+1].pos); for(var j=aMin.length-1;j>=0;j--){if(aMin[j].len>len){aMin[j].len=len;aMin.index=j;break;}}
}}
 
aMin.sort(fnSortByIndex);var getTriangle=function addWallsPutTriangle(pointA,pointB,pointC,color){return new CSG.Polygon([pointA,pointB,pointC],color);};var bpoint=bottomPoints[0],tpoint=topPoints[0],secondPoint,nBotFacet,nTopFacet; for(var iB=0,iT=0,iMax=iTopLen+iBotLen;iB+iT<iMax;){if(aMin.length){if(bMoreTops&&iT==aMin[0].index){ secondPoint=topPoints[++iT];walls.push(getTriangle(secondPoint,tpoint,bpoint,color));tpoint=secondPoint;aMin.shift();continue;}else if(bMoreBottoms&&iB==aMin[0].index){secondPoint=bottomPoints[++iB];walls.push(getTriangle(tpoint,bpoint,secondPoint,color));bpoint=secondPoint;aMin.shift();continue;}} 
if(iB<iBotLen){ nBotFacet=tpoint.pos.distanceToSquared(bottomPoints[iB+1].pos);}else{nBotFacet=Infinity;}
if(iT<iTopLen){ nTopFacet=bpoint.pos.distanceToSquared(topPoints[iT+1].pos);}else{nTopFacet=Infinity;}
if(nBotFacet<=nTopFacet){secondPoint=bottomPoints[++iB];walls.push(getTriangle(tpoint,bpoint,secondPoint,color));bpoint=secondPoint;}else if(iT<iTopLen){ secondPoint=topPoints[++iT];walls.push(getTriangle(secondPoint,tpoint,bpoint,color));tpoint=secondPoint;};}
return walls;}};CSG.Polygon.verticesConvex=function(vertices,planenormal){var numvertices=vertices.length;if(numvertices>2){var prevprevpos=vertices[numvertices-2].pos;var prevpos=vertices[numvertices-1].pos;for(var i=0;i<numvertices;i++){var pos=vertices[i].pos;if(!CSG.Polygon.isConvexPoint(prevprevpos,prevpos,pos,planenormal)){return false;}
prevprevpos=prevpos;prevpos=pos;}}
return true;};CSG.Polygon.createFromPoints=function(points,shared,plane){var normal;if(arguments.length<3){normal=new CSG.Vector3D(0,0,0);}else{normal=plane.normal;}
var vertices=[];points.map(function(p){var vec=new CSG.Vector3D(p);var vertex=new CSG.Vertex(vec);vertices.push(vertex);});var polygon;if(arguments.length<3){polygon=new CSG.Polygon(vertices,shared);}else{polygon=new CSG.Polygon(vertices,shared,plane);}
return polygon;};

CSG.Polygon.isConvexPoint=function(prevpoint,point,nextpoint,normal){var crossproduct=point.minus(prevpoint).cross(nextpoint.minus(point));var crossdotnormal=crossproduct.dot(normal);return(crossdotnormal>=0);};CSG.Polygon.isStrictlyConvexPoint=function(prevpoint,point,nextpoint,normal){var crossproduct=point.minus(prevpoint).cross(nextpoint.minus(point));var crossdotnormal=crossproduct.dot(normal);return(crossdotnormal>=1e-5);};
CSG.Polygon.Shared=function(color){this.color=color;};CSG.Polygon.Shared.fromObject=function(obj){return new CSG.Polygon.Shared(obj.color);};CSG.Polygon.Shared.prototype={getTag:function(){var result=this.tag;if(!result){result=CSG.getTag();this.tag=result;}
return result;}, getHash:function(){if(!this.color)return"null";return""+this.color[0]+"/"+this.color[1]+"/"+this.color[2];}};CSG.Polygon.defaultShared=new CSG.Polygon.Shared(null);






CSG.PolygonTreeNode=function(){this.parent=null;this.children=[];this.polygon=null;this.removed=false;};CSG.PolygonTreeNode.prototype={
addPolygons:function(polygons){if(!this.isRootNode()) 
throw new Error("Assertion failed");var _this=this;polygons.map(function(polygon){_this.addChild(polygon);});},

 remove:function(){if(!this.removed){this.removed=true;if(_CSGDEBUG){if(this.isRootNode())throw new Error("Assertion failed"); if(this.children.length)throw new Error("Assertion failed");}
var parentschildren=this.parent.children;var i=parentschildren.indexOf(this);if(i<0)throw new Error("Assertion failed");parentschildren.splice(i,1);this.parent.recursivelyInvalidatePolygon();}},isRemoved:function(){return this.removed;},isRootNode:function(){return!this.parent;}, invert:function(){if(!this.isRootNode())throw new Error("Assertion failed"); this.invertSub();},getPolygon:function(){if(!this.polygon)throw new Error("Assertion failed"); return this.polygon;},getPolygons:function(result){if(this.polygon){result.push(this.polygon);}else{var childpolygons=[];this.children.map(function(child){child.getPolygons(childpolygons);});childpolygons.map(function(p){result.push(p);});}},

splitByPlane:function(plane,coplanarfrontnodes,coplanarbacknodes,frontnodes,backnodes){var children=this.children;var numchildren=children.length;if(numchildren>0){ for(var i=0;i<numchildren;i++){children[i].splitByPlane(plane,coplanarfrontnodes,coplanarbacknodes,frontnodes,backnodes);}}else{var polygon=this.polygon;if(polygon){var bound=polygon.boundingSphere();var sphereradius=bound[1]+1e-4;var planenormal=plane.normal;var spherecenter=bound[0];var d=planenormal.dot(spherecenter)-plane.w;if(d>sphereradius){frontnodes.push(this);}else if(d<-sphereradius){backnodes.push(this);}else{var splitresult=plane.splitPolygon(polygon);switch(splitresult.type){case 0:coplanarfrontnodes.push(this);break;case 1:coplanarbacknodes.push(this);break;case 2:frontnodes.push(this);break;case 3:backnodes.push(this);break;case 4:if(splitresult.front){var frontnode=this.addChild(splitresult.front);frontnodes.push(frontnode);}
if(splitresult.back){var backnode=this.addChild(splitresult.back);backnodes.push(backnode);}
break;}}}}},


 addChild:function(polygon){var newchild=new CSG.PolygonTreeNode();newchild.parent=this;newchild.polygon=polygon;this.children.push(newchild);return newchild;},invertSub:function(){if(this.polygon){this.polygon=this.polygon.flipped();}
this.children.map(function(child){child.invertSub();});},recursivelyInvalidatePolygon:function(){if(this.polygon){this.polygon=null;if(this.parent){this.parent.recursivelyInvalidatePolygon();}}}};


CSG.Tree=function(polygons){this.polygonTree=new CSG.PolygonTreeNode();this.rootnode=new CSG.Node(null);if(polygons)this.addPolygons(polygons);};CSG.Tree.prototype={invert:function(){this.polygonTree.invert();this.rootnode.invert();},
clipTo:function(tree,alsoRemovecoplanarFront){alsoRemovecoplanarFront=alsoRemovecoplanarFront?true:false;this.rootnode.clipTo(tree,alsoRemovecoplanarFront);},allPolygons:function(){var result=[];this.polygonTree.getPolygons(result);return result;},addPolygons:function(polygons){var _this=this;var polygontreenodes=polygons.map(function(p){return _this.polygonTree.addChild(p);});this.rootnode.addPolygonTreeNodes(polygontreenodes);}};





CSG.Node=function(parent){this.plane=null;this.front=null;this.back=null;this.polygontreenodes=[];this.parent=parent;};CSG.Node.prototype={invert:function(){if(this.plane)this.plane=this.plane.flipped();if(this.front)this.front.invert();if(this.back)this.back.invert();var temp=this.front;this.front=this.back;this.back=temp;},
 clipPolygons:function(polygontreenodes,alsoRemovecoplanarFront){if(this.plane){var backnodes=[];var frontnodes=[];var coplanarfrontnodes=alsoRemovecoplanarFront?backnodes:frontnodes;var plane=this.plane;var numpolygontreenodes=polygontreenodes.length;for(var i=0;i<numpolygontreenodes;i++){var node=polygontreenodes[i];if(!node.isRemoved()){node.splitByPlane(plane,coplanarfrontnodes,backnodes,frontnodes,backnodes);}}
if(this.front&&(frontnodes.length>0)){this.front.clipPolygons(frontnodes,alsoRemovecoplanarFront);}
var numbacknodes=backnodes.length;if(this.back&&(numbacknodes>0)){this.back.clipPolygons(backnodes,alsoRemovecoplanarFront);}else{for(var i=0;i<numbacknodes;i++){backnodes[i].remove();}}}},
clipTo:function(tree,alsoRemovecoplanarFront){if(this.polygontreenodes.length>0){tree.rootnode.clipPolygons(this.polygontreenodes,alsoRemovecoplanarFront);}
if(this.front)this.front.clipTo(tree,alsoRemovecoplanarFront);if(this.back)this.back.clipTo(tree,alsoRemovecoplanarFront);},addPolygonTreeNodes:function(polygontreenodes){if(polygontreenodes.length===0)return;var _this=this;if(!this.plane){var bestplane=polygontreenodes[0].getPolygon().plane;this.plane=bestplane;}
var frontnodes=[];var backnodes=[];polygontreenodes.map(function(polygontreenode){polygontreenode.splitByPlane(_this.plane,_this.polygontreenodes,backnodes,frontnodes,backnodes);});if(frontnodes.length>0){if(!this.front)this.front=new CSG.Node(this);this.front.addPolygonTreeNodes(frontnodes);}
if(backnodes.length>0){if(!this.back)this.back=new CSG.Node(this);this.back.addPolygonTreeNodes(backnodes);}},getParentPlaneNormals:function(normals,maxdepth){if(maxdepth>0){if(this.parent){normals.push(this.parent.plane.normal);this.parent.getParentPlaneNormals(normals,maxdepth-1);}}}};CSG.Matrix4x4=function(elements){if(arguments.length>=1){this.elements=elements;}else{ this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];}};CSG.Matrix4x4.prototype={plus:function(m){var r=[];for(var i=0;i<16;i++){r[i]=this.elements[i]+m.elements[i];}
return new CSG.Matrix4x4(r);},minus:function(m){var r=[];for(var i=0;i<16;i++){r[i]=this.elements[i]-m.elements[i];}
return new CSG.Matrix4x4(r);},multiply:function(m){var this0=this.elements[0];var this1=this.elements[1];var this2=this.elements[2];var this3=this.elements[3];var this4=this.elements[4];var this5=this.elements[5];var this6=this.elements[6];var this7=this.elements[7];var this8=this.elements[8];var this9=this.elements[9];var this10=this.elements[10];var this11=this.elements[11];var this12=this.elements[12];var this13=this.elements[13];var this14=this.elements[14];var this15=this.elements[15];var m0=m.elements[0];var m1=m.elements[1];var m2=m.elements[2];var m3=m.elements[3];var m4=m.elements[4];var m5=m.elements[5];var m6=m.elements[6];var m7=m.elements[7];var m8=m.elements[8];var m9=m.elements[9];var m10=m.elements[10];var m11=m.elements[11];var m12=m.elements[12];var m13=m.elements[13];var m14=m.elements[14];var m15=m.elements[15];var result=[];result[0]=this0*m0+this1*m4+this2*m8+this3*m12;result[1]=this0*m1+this1*m5+this2*m9+this3*m13;result[2]=this0*m2+this1*m6+this2*m10+this3*m14;result[3]=this0*m3+this1*m7+this2*m11+this3*m15;result[4]=this4*m0+this5*m4+this6*m8+this7*m12;result[5]=this4*m1+this5*m5+this6*m9+this7*m13;result[6]=this4*m2+this5*m6+this6*m10+this7*m14;result[7]=this4*m3+this5*m7+this6*m11+this7*m15;result[8]=this8*m0+this9*m4+this10*m8+this11*m12;result[9]=this8*m1+this9*m5+this10*m9+this11*m13;result[10]=this8*m2+this9*m6+this10*m10+this11*m14;result[11]=this8*m3+this9*m7+this10*m11+this11*m15;result[12]=this12*m0+this13*m4+this14*m8+this15*m12;result[13]=this12*m1+this13*m5+this14*m9+this15*m13;result[14]=this12*m2+this13*m6+this14*m10+this15*m14;result[15]=this12*m3+this13*m7+this14*m11+this15*m15;return new CSG.Matrix4x4(result);},clone:function(){var elements=this.elements.map(function(p){return p;});return new CSG.Matrix4x4(elements);}, 
rightMultiply1x3Vector:function(v){var v0=v._x;var v1=v._y;var v2=v._z;var v3=1;var x=v0*this.elements[0]+v1*this.elements[1]+v2*this.elements[2]+v3*this.elements[3];var y=v0*this.elements[4]+v1*this.elements[5]+v2*this.elements[6]+v3*this.elements[7];var z=v0*this.elements[8]+v1*this.elements[9]+v2*this.elements[10]+v3*this.elements[11];var w=v0*this.elements[12]+v1*this.elements[13]+v2*this.elements[14]+v3*this.elements[15];if(w!=1){var invw=1.0/w;x*=invw;y*=invw;z*=invw;}
return new CSG.Vector3D(x,y,z);},
 
leftMultiply1x3Vector:function(v){var v0=v._x;var v1=v._y;var v2=v._z;var v3=1;var x=v0*this.elements[0]+v1*this.elements[4]+v2*this.elements[8]+v3*this.elements[12];var y=v0*this.elements[1]+v1*this.elements[5]+v2*this.elements[9]+v3*this.elements[13];var z=v0*this.elements[2]+v1*this.elements[6]+v2*this.elements[10]+v3*this.elements[14];var w=v0*this.elements[3]+v1*this.elements[7]+v2*this.elements[11]+v3*this.elements[15];if(w!=1){var invw=1.0/w;x*=invw;y*=invw;z*=invw;}
return new CSG.Vector3D(x,y,z);}, 
rightMultiply1x2Vector:function(v){var v0=v.x;var v1=v.y;var v2=0;var v3=1;var x=v0*this.elements[0]+v1*this.elements[1]+v2*this.elements[2]+v3*this.elements[3];var y=v0*this.elements[4]+v1*this.elements[5]+v2*this.elements[6]+v3*this.elements[7];var z=v0*this.elements[8]+v1*this.elements[9]+v2*this.elements[10]+v3*this.elements[11];var w=v0*this.elements[12]+v1*this.elements[13]+v2*this.elements[14]+v3*this.elements[15];if(w!=1){var invw=1.0/w;x*=invw;y*=invw;z*=invw;}
return new CSG.Vector2D(x,y);},
 
leftMultiply1x2Vector:function(v){var v0=v.x;var v1=v.y;var v2=0;var v3=1;var x=v0*this.elements[0]+v1*this.elements[4]+v2*this.elements[8]+v3*this.elements[12];var y=v0*this.elements[1]+v1*this.elements[5]+v2*this.elements[9]+v3*this.elements[13];var z=v0*this.elements[2]+v1*this.elements[6]+v2*this.elements[10]+v3*this.elements[14];var w=v0*this.elements[3]+v1*this.elements[7]+v2*this.elements[11]+v3*this.elements[15];if(w!=1){var invw=1.0/w;x*=invw;y*=invw;z*=invw;}
return new CSG.Vector2D(x,y);}, isMirroring:function(){var u=new CSG.Vector3D(this.elements[0],this.elements[4],this.elements[8]);var v=new CSG.Vector3D(this.elements[1],this.elements[5],this.elements[9]);var w=new CSG.Vector3D(this.elements[2],this.elements[6],this.elements[10]);
 var mirrorvalue=u.cross(v).dot(w);var ismirror=(mirrorvalue<0);return ismirror;}};CSG.Matrix4x4.unity=function(){return new CSG.Matrix4x4();};CSG.Matrix4x4.rotationX=function(degrees){var radians=degrees*Math.PI*(1.0/180.0);var cos=Math.cos(radians);var sin=Math.sin(radians);var els=[1,0,0,0,0,cos,sin,0,0,-sin,cos,0,0,0,0,1];return new CSG.Matrix4x4(els);};CSG.Matrix4x4.rotationY=function(degrees){var radians=degrees*Math.PI*(1.0/180.0);var cos=Math.cos(radians);var sin=Math.sin(radians);var els=[cos,0,-sin,0,0,1,0,0,sin,0,cos,0,0,0,0,1];return new CSG.Matrix4x4(els);};CSG.Matrix4x4.rotationZ=function(degrees){var radians=degrees*Math.PI*(1.0/180.0);var cos=Math.cos(radians);var sin=Math.sin(radians);var els=[cos,sin,0,0,-sin,cos,0,0,0,0,1,0,0,0,0,1];return new CSG.Matrix4x4(els);};CSG.Matrix4x4.rotation=function(rotationCenter,rotationAxis,degrees){rotationCenter=new CSG.Vector3D(rotationCenter);rotationAxis=new CSG.Vector3D(rotationAxis);var rotationPlane=CSG.Plane.fromNormalAndPoint(rotationAxis,rotationCenter);var orthobasis=new CSG.OrthoNormalBasis(rotationPlane);var transformation=CSG.Matrix4x4.translation(rotationCenter.negated());transformation=transformation.multiply(orthobasis.getProjectionMatrix());transformation=transformation.multiply(CSG.Matrix4x4.rotationZ(degrees));transformation=transformation.multiply(orthobasis.getInverseProjectionMatrix());transformation=transformation.multiply(CSG.Matrix4x4.translation(rotationCenter));return transformation;};CSG.Matrix4x4.translation=function(v){ var vec=new CSG.Vector3D(v);var els=[1,0,0,0,0,1,0,0,0,0,1,0,vec.x,vec.y,vec.z,1];return new CSG.Matrix4x4(els);};CSG.Matrix4x4.mirroring=function(plane){var nx=plane.normal.x;var ny=plane.normal.y;var nz=plane.normal.z;var w=plane.w;var els=[(1.0-2.0*nx*nx),(-2.0*ny*nx),(-2.0*nz*nx),0,(-2.0*nx*ny),(1.0-2.0*ny*ny),(-2.0*nz*ny),0,(-2.0*nx*nz),(-2.0*ny*nz),(1.0-2.0*nz*nz),0,(-2.0*nx*w),(-2.0*ny*w),(-2.0*nz*w),1];return new CSG.Matrix4x4(els);};CSG.Matrix4x4.scaling=function(v){ var vec=new CSG.Vector3D(v);var els=[vec.x,0,0,0,0,vec.y,0,0,0,0,vec.z,0,0,0,0,1];return new CSG.Matrix4x4(els);};CSG.Vector2D=function(x,y){if(arguments.length==2){this._x=parseFloat(x);this._y=parseFloat(y);}else{var ok=true;if(arguments.length==1){if(typeof(x)=="object"){if(x instanceof CSG.Vector2D){this._x=x._x;this._y=x._y;}else if(x instanceof Array){this._x=parseFloat(x[0]);this._y=parseFloat(x[1]);}else if(('x'in x)&&('y'in x)){this._x=parseFloat(x.x);this._y=parseFloat(x.y);}else ok=false;}else{var v=parseFloat(x);this._x=v;this._y=v;}}else ok=false;if(ok){if((!CSG.IsFloat(this._x))||(!CSG.IsFloat(this._y)))ok=false;}
if(!ok){throw new Error("wrong arguments");}}};CSG.Vector2D.fromAngle=function(radians){return CSG.Vector2D.fromAngleRadians(radians);};CSG.Vector2D.fromAngleDegrees=function(degrees){var radians=Math.PI*degrees/180;return CSG.Vector2D.fromAngleRadians(radians);};CSG.Vector2D.fromAngleRadians=function(radians){return CSG.Vector2D.Create(Math.cos(radians),Math.sin(radians));};
CSG.Vector2D.Create=function(x,y){var result=Object.create(CSG.Vector2D.prototype);result._x=x;result._y=y;return result;};CSG.Vector2D.prototype={get x(){return this._x;},get y(){return this._y;},set x(v){throw new Error("Vector2D is immutable");},set y(v){throw new Error("Vector2D is immutable");},toVector3D:function(z){return new CSG.Vector3D(this._x,this._y,z);},equals:function(a){return(this._x==a._x)&&(this._y==a._y);},clone:function(){return CSG.Vector2D.Create(this._x,this._y);},negated:function(){return CSG.Vector2D.Create(-this._x,-this._y);},plus:function(a){return CSG.Vector2D.Create(this._x+a._x,this._y+a._y);},minus:function(a){return CSG.Vector2D.Create(this._x-a._x,this._y-a._y);},times:function(a){return CSG.Vector2D.Create(this._x*a,this._y*a);},dividedBy:function(a){return CSG.Vector2D.Create(this._x/a,this._y/a);},dot:function(a){return this._x*a._x+this._y*a._y;},lerp:function(a,t){return this.plus(a.minus(this).times(t));},length:function(){return Math.sqrt(this.dot(this));},distanceTo:function(a){return this.minus(a).length();},distanceToSquared:function(a){return this.minus(a).lengthSquared();},lengthSquared:function(){return this.dot(this);},unit:function(){return this.dividedBy(this.length());},cross:function(a){return this._x*a._y-this._y*a._x;}, normal:function(){return CSG.Vector2D.Create(this._y,-this._x);}, 
multiply4x4:function(matrix4x4){return matrix4x4.leftMultiply1x2Vector(this);},transform:function(matrix4x4){return matrix4x4.leftMultiply1x2Vector(this);},angle:function(){return this.angleRadians();},angleDegrees:function(){var radians=this.angleRadians();return 180*radians/Math.PI;},angleRadians:function(){ return Math.atan2(this._y,this._x);},min:function(p){return CSG.Vector2D.Create(Math.min(this._x,p._x),Math.min(this._y,p._y));},max:function(p){return CSG.Vector2D.Create(Math.max(this._x,p._x),Math.max(this._y,p._y));},toString:function(){return"("+this._x.toFixed(2)+", "+this._y.toFixed(2)+")";},abs:function(){return CSG.Vector2D.Create(Math.abs(this._x),Math.abs(this._y));},};


CSG.Line2D=function(normal,w){normal=new CSG.Vector2D(normal);w=parseFloat(w);var l=normal.length();w*=l;normal=normal.times(1.0/l);this.normal=normal;this.w=w;};CSG.Line2D.fromPoints=function(p1,p2){p1=new CSG.Vector2D(p1);p2=new CSG.Vector2D(p2);var direction=p2.minus(p1);var normal=direction.normal().negated().unit();var w=p1.dot(normal);return new CSG.Line2D(normal,w);};CSG.Line2D.prototype={reverse:function(){return new CSG.Line2D(this.normal.negated(),-this.w);},equals:function(l){return(l.normal.equals(this.normal)&&(l.w==this.w));},origin:function(){return this.normal.times(this.w);},direction:function(){return this.normal.normal();},xAtY:function(y){ 
var x=(this.w-this.normal._y*y)/this.normal.x;return x;},absDistanceToPoint:function(point){point=new CSG.Vector2D(point);var point_projected=point.dot(this.normal);var distance=Math.abs(point_projected-this.w);return distance;}, intersectWithLine:function(line2d){var point=CSG.solve2Linear(this.normal.x,this.normal.y,line2d.normal.x,line2d.normal.y,this.w,line2d.w);point=new CSG.Vector2D(point); return point;},transform:function(matrix4x4){var origin=new CSG.Vector2D(0,0);var pointOnPlane=this.normal.times(this.w);var neworigin=origin.multiply4x4(matrix4x4);var neworiginPlusNormal=this.normal.multiply4x4(matrix4x4);var newnormal=neworiginPlusNormal.minus(neworigin);var newpointOnPlane=pointOnPlane.multiply4x4(matrix4x4);var neww=newnormal.dot(newpointOnPlane);return new CSG.Line2D(newnormal,neww);}};


CSG.Line3D=function(point,direction){point=new CSG.Vector3D(point);direction=new CSG.Vector3D(direction);this.point=point;this.direction=direction.unit();};CSG.Line3D.fromPoints=function(p1,p2){p1=new CSG.Vector3D(p1);p2=new CSG.Vector3D(p2);var direction=p2.minus(p1).unit();return new CSG.Line3D(p1,direction);};CSG.Line3D.fromPlanes=function(p1,p2){var direction=p1.normal.cross(p2.normal);var l=direction.length();if(l<1e-10){throw new Error("Parallel planes");}
direction=direction.times(1.0/l);var mabsx=Math.abs(direction.x);var mabsy=Math.abs(direction.y);var mabsz=Math.abs(direction.z);var origin;if((mabsx>=mabsy)&&(mabsx>=mabsz)){
var r=CSG.solve2Linear(p1.normal.y,p1.normal.z,p2.normal.y,p2.normal.z,p1.w,p2.w);origin=new CSG.Vector3D(0,r[0],r[1]);}else if((mabsy>=mabsx)&&(mabsy>=mabsz)){var r=CSG.solve2Linear(p1.normal.x,p1.normal.z,p2.normal.x,p2.normal.z,p1.w,p2.w);origin=new CSG.Vector3D(r[0],0,r[1]);}else{var r=CSG.solve2Linear(p1.normal.x,p1.normal.y,p2.normal.x,p2.normal.y,p1.w,p2.w);origin=new CSG.Vector3D(r[0],r[1],0);}
return new CSG.Line3D(origin,direction);};CSG.Line3D.prototype={intersectWithPlane:function(plane){
 var labda=(plane.w-plane.normal.dot(this.point))/plane.normal.dot(this.direction);var point=this.point.plus(this.direction.times(labda));return point;},clone:function(line){return new CSG.Line3D(this.point.clone(),this.direction.clone());},reverse:function(){return new CSG.Line3D(this.point.clone(),this.direction.negated());},transform:function(matrix4x4){var newpoint=this.point.multiply4x4(matrix4x4);var pointPlusDirection=this.point.plus(this.direction);var newPointPlusDirection=pointPlusDirection.multiply4x4(matrix4x4);var newdirection=newPointPlusDirection.minus(newpoint);return new CSG.Line3D(newpoint,newdirection);},closestPointOnLine:function(point){point=new CSG.Vector3D(point);var t=point.minus(this.point).dot(this.direction)/this.direction.dot(this.direction);var closestpoint=this.point.plus(this.direction.times(t));return closestpoint;},distanceToPoint:function(point){point=new CSG.Vector3D(point);var closestpoint=this.closestPointOnLine(point);var distancevector=point.minus(closestpoint);var distance=distancevector.length();return distance;},equals:function(line3d){if(!this.direction.equals(line3d.direction))return false;var distance=this.distanceToPoint(line3d.point);if(distance>1e-8)return false;return true;}};

CSG.OrthoNormalBasis=function(plane,rightvector){if(arguments.length<2){rightvector=plane.normal.randomNonParallelVector();}else{rightvector=new CSG.Vector3D(rightvector);}
this.v=plane.normal.cross(rightvector).unit();this.u=this.v.cross(plane.normal);this.plane=plane;this.planeorigin=plane.normal.times(plane.w);};


CSG.OrthoNormalBasis.GetCartesian=function(xaxisid,yaxisid){var axisid=xaxisid+"/"+yaxisid;var planenormal,rightvector;if(axisid=="X/Y")
{planenormal=[0,0,1];rightvector=[1,0,0];}
else if(axisid=="Y/-X")
{planenormal=[0,0,1];rightvector=[0,1,0];}
else if(axisid=="-X/-Y")
{planenormal=[0,0,1];rightvector=[-1,0,0];}
else if(axisid=="-Y/X")
{planenormal=[0,0,1];rightvector=[0,-1,0];}
else if(axisid=="-X/Y")
{planenormal=[0,0,-1];rightvector=[-1,0,0];}
else if(axisid=="-Y/-X")
{planenormal=[0,0,-1];rightvector=[0,-1,0];}
else if(axisid=="X/-Y")
{planenormal=[0,0,-1];rightvector=[1,0,0];}
else if(axisid=="Y/X")
{planenormal=[0,0,-1];rightvector=[0,1,0];}
else if(axisid=="X/Z")
{planenormal=[0,-1,0];rightvector=[1,0,0];}
else if(axisid=="Z/-X")
{planenormal=[0,-1,0];rightvector=[0,0,1];}
else if(axisid=="-X/-Z")
{planenormal=[0,-1,0];rightvector=[-1,0,0];}
else if(axisid=="-Z/X")
{planenormal=[0,-1,0];rightvector=[0,0,-1];}
else if(axisid=="-X/Z")
{planenormal=[0,1,0];rightvector=[-1,0,0];}
else if(axisid=="-Z/-X")
{planenormal=[0,1,0];rightvector=[0,0,-1];}
else if(axisid=="X/-Z")
{planenormal=[0,1,0];rightvector=[1,0,0];}
else if(axisid=="Z/X")
{planenormal=[0,1,0];rightvector=[0,0,1];}
else if(axisid=="Y/Z")
{planenormal=[1,0,0];rightvector=[0,1,0];}
else if(axisid=="Z/-Y")
{planenormal=[1,0,0];rightvector=[0,0,1];}
else if(axisid=="-Y/-Z")
{planenormal=[1,0,0];rightvector=[0,-1,0];}
else if(axisid=="-Z/Y")
{planenormal=[1,0,0];rightvector=[0,0,-1];}
else if(axisid=="-Y/Z")
{planenormal=[-1,0,0];rightvector=[0,-1,0];}
else if(axisid=="-Z/-Y")
{planenormal=[-1,0,0];rightvector=[0,0,-1];}
else if(axisid=="Y/-Z")
{planenormal=[-1,0,0];rightvector=[0,1,0];}
else if(axisid=="Z/Y")
{planenormal=[-1,0,0];rightvector=[0,0,1];}
else
{throw new Error("CSG.OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");}
return new CSG.OrthoNormalBasis(new CSG.Plane(new CSG.Vector3D(planenormal),0),new CSG.Vector3D(rightvector));};CSG.OrthoNormalBasis.Z0Plane=function(){var plane=new CSG.Plane(new CSG.Vector3D([0,0,1]),0);return new CSG.OrthoNormalBasis(plane,new CSG.Vector3D([1,0,0]));};CSG.OrthoNormalBasis.prototype={getProjectionMatrix:function(){return new CSG.Matrix4x4([this.u.x,this.v.x,this.plane.normal.x,0,this.u.y,this.v.y,this.plane.normal.y,0,this.u.z,this.v.z,this.plane.normal.z,0,0,0,-this.plane.w,1]);},getInverseProjectionMatrix:function(){var p=this.plane.normal.times(this.plane.w);return new CSG.Matrix4x4([this.u.x,this.u.y,this.u.z,0,this.v.x,this.v.y,this.v.z,0,this.plane.normal.x,this.plane.normal.y,this.plane.normal.z,0,p.x,p.y,p.z,1]);},to2D:function(vec3){return new CSG.Vector2D(vec3.dot(this.u),vec3.dot(this.v));},to3D:function(vec2){return this.planeorigin.plus(this.u.times(vec2.x)).plus(this.v.times(vec2.y));},line3Dto2D:function(line3d){var a=line3d.point;var b=line3d.direction.plus(a);var a2d=this.to2D(a);var b2d=this.to2D(b);return CSG.Line2D.fromPoints(a2d,b2d);},line2Dto3D:function(line2d){var a=line2d.origin();var b=line2d.direction().plus(a);var a3d=this.to3D(a);var b3d=this.to3D(b);return CSG.Line3D.fromPoints(a3d,b3d);},transform:function(matrix4x4){ var newplane=this.plane.transform(matrix4x4);var rightpoint_transformed=this.u.transform(matrix4x4);var origin_transformed=new CSG.Vector3D(0,0,0).transform(matrix4x4);var newrighthandvector=rightpoint_transformed.minus(origin_transformed);var newbasis=new CSG.OrthoNormalBasis(newplane,newrighthandvector);return newbasis;}};function insertSorted(array,element,comparefunc){var leftbound=0;var rightbound=array.length;while(rightbound>leftbound){var testindex=Math.floor((leftbound+rightbound)/2);var testelement=array[testindex];var compareresult=comparefunc(element,testelement);if(compareresult>0)
{leftbound=testindex+1;}else{rightbound=testindex;}}
array.splice(leftbound,0,element);}

CSG.interpolateBetween2DPointsForY=function(point1,point2,y){var f1=y-point1.y;var f2=point2.y-point1.y;if(f2<0){f1=-f1;f2=-f2;}
var t;if(f1<=0){t=0.0;}else if(f1>=f2){t=1.0;}else if(f2<1e-10){t=0.5;}else{t=f1/f2;}
var result=point1.x+t*(point2.x-point1.x);return result;};
CSG.reTesselateCoplanarPolygons=function(sourcepolygons,destpolygons){var EPS=1e-5;var numpolygons=sourcepolygons.length;if(numpolygons>0){var plane=sourcepolygons[0].plane;var shared=sourcepolygons[0].shared;var orthobasis=new CSG.OrthoNormalBasis(plane);var polygonvertices2d=[]; var polygontopvertexindexes=[]; var topy2polygonindexes={};var ycoordinatetopolygonindexes={};var xcoordinatebins={};var ycoordinatebins={};

var ycoordinateBinningFactor=1.0/EPS*10;for(var polygonindex=0;polygonindex<numpolygons;polygonindex++){var poly3d=sourcepolygons[polygonindex];var vertices2d=[];var numvertices=poly3d.vertices.length;var minindex=-1;if(numvertices>0){var miny,maxy,maxindex;for(var i=0;i<numvertices;i++){var pos2d=orthobasis.to2D(poly3d.vertices[i].pos);
var ycoordinatebin=Math.floor(pos2d.y*ycoordinateBinningFactor);var newy;if(ycoordinatebin in ycoordinatebins){newy=ycoordinatebins[ycoordinatebin];}else if(ycoordinatebin+1 in ycoordinatebins){newy=ycoordinatebins[ycoordinatebin+1];}else if(ycoordinatebin-1 in ycoordinatebins){newy=ycoordinatebins[ycoordinatebin-1];}else{newy=pos2d.y;ycoordinatebins[ycoordinatebin]=pos2d.y;}
pos2d=CSG.Vector2D.Create(pos2d.x,newy);vertices2d.push(pos2d);var y=pos2d.y;if((i===0)||(y<miny)){miny=y;minindex=i;}
if((i===0)||(y>maxy)){maxy=y;maxindex=i;}
if(!(y in ycoordinatetopolygonindexes)){ycoordinatetopolygonindexes[y]={};}
ycoordinatetopolygonindexes[y][polygonindex]=true;}
if(miny>=maxy){vertices2d=[];}else{if(!(miny in topy2polygonindexes)){topy2polygonindexes[miny]=[];}
topy2polygonindexes[miny].push(polygonindex);}}
vertices2d.reverse();minindex=numvertices-minindex-1;polygonvertices2d.push(vertices2d);polygontopvertexindexes.push(minindex);}
var ycoordinates=[];for(var ycoordinate in ycoordinatetopolygonindexes)ycoordinates.push(ycoordinate);ycoordinates.sort(fnNumberSort);






 
var activepolygons=[];var prevoutpolygonrow=[];for(var yindex=0;yindex<ycoordinates.length;yindex++){var newoutpolygonrow=[];var ycoordinate_as_string=ycoordinates[yindex];var ycoordinate=Number(ycoordinate_as_string);


var polygonindexeswithcorner=ycoordinatetopolygonindexes[ycoordinate_as_string];for(var activepolygonindex=0;activepolygonindex<activepolygons.length;++activepolygonindex){var activepolygon=activepolygons[activepolygonindex];var polygonindex=activepolygon.polygonindex;if(polygonindexeswithcorner[polygonindex]){var vertices2d=polygonvertices2d[polygonindex];var numvertices=vertices2d.length;var newleftvertexindex=activepolygon.leftvertexindex;var newrightvertexindex=activepolygon.rightvertexindex;while(true){var nextleftvertexindex=newleftvertexindex+1;if(nextleftvertexindex>=numvertices)nextleftvertexindex=0;if(vertices2d[nextleftvertexindex].y!=ycoordinate)break;newleftvertexindex=nextleftvertexindex;}
var nextrightvertexindex=newrightvertexindex-1;if(nextrightvertexindex<0)nextrightvertexindex=numvertices-1;if(vertices2d[nextrightvertexindex].y==ycoordinate){newrightvertexindex=nextrightvertexindex;}
if((newleftvertexindex!=activepolygon.leftvertexindex)&&(newleftvertexindex==newrightvertexindex)){
activepolygons.splice(activepolygonindex,1);--activepolygonindex;}else{activepolygon.leftvertexindex=newleftvertexindex;activepolygon.rightvertexindex=newrightvertexindex;activepolygon.topleft=vertices2d[newleftvertexindex];activepolygon.topright=vertices2d[newrightvertexindex];var nextleftvertexindex=newleftvertexindex+1;if(nextleftvertexindex>=numvertices)nextleftvertexindex=0;activepolygon.bottomleft=vertices2d[nextleftvertexindex];var nextrightvertexindex=newrightvertexindex-1;if(nextrightvertexindex<0)nextrightvertexindex=numvertices-1;activepolygon.bottomright=vertices2d[nextrightvertexindex];}}
} 
var nextycoordinate;if(yindex>=ycoordinates.length-1){activepolygons=[];nextycoordinate=null;}else
{nextycoordinate=Number(ycoordinates[yindex+1]);var middleycoordinate=0.5*(ycoordinate+nextycoordinate);var startingpolygonindexes=topy2polygonindexes[ycoordinate_as_string];for(var polygonindex_key in startingpolygonindexes){var polygonindex=startingpolygonindexes[polygonindex_key];var vertices2d=polygonvertices2d[polygonindex];var numvertices=vertices2d.length;var topvertexindex=polygontopvertexindexes[polygonindex];var topleftvertexindex=topvertexindex;while(true){var i=topleftvertexindex+1;if(i>=numvertices)i=0;if(vertices2d[i].y!=ycoordinate)break;if(i==topvertexindex)break; topleftvertexindex=i;}
var toprightvertexindex=topvertexindex;while(true){var i=toprightvertexindex-1;if(i<0)i=numvertices-1;if(vertices2d[i].y!=ycoordinate)break;if(i==topleftvertexindex)break; toprightvertexindex=i;}
var nextleftvertexindex=topleftvertexindex+1;if(nextleftvertexindex>=numvertices)nextleftvertexindex=0;var nextrightvertexindex=toprightvertexindex-1;if(nextrightvertexindex<0)nextrightvertexindex=numvertices-1;var newactivepolygon={polygonindex:polygonindex,leftvertexindex:topleftvertexindex,rightvertexindex:toprightvertexindex,topleft:vertices2d[topleftvertexindex],topright:vertices2d[toprightvertexindex],bottomleft:vertices2d[nextleftvertexindex],bottomright:vertices2d[nextrightvertexindex],};insertSorted(activepolygons,newactivepolygon,function(el1,el2){var x1=CSG.interpolateBetween2DPointsForY(el1.topleft,el1.bottomleft,middleycoordinate);var x2=CSG.interpolateBetween2DPointsForY(el2.topleft,el2.bottomleft,middleycoordinate);if(x1>x2)return 1;if(x1<x2)return-1;return 0;});} 
}  

if(true){
for(var activepolygon_key in activepolygons){var activepolygon=activepolygons[activepolygon_key];var polygonindex=activepolygon.polygonindex;var vertices2d=polygonvertices2d[polygonindex];var numvertices=vertices2d.length;var x=CSG.interpolateBetween2DPointsForY(activepolygon.topleft,activepolygon.bottomleft,ycoordinate);var topleft=CSG.Vector2D.Create(x,ycoordinate);x=CSG.interpolateBetween2DPointsForY(activepolygon.topright,activepolygon.bottomright,ycoordinate);var topright=CSG.Vector2D.Create(x,ycoordinate);x=CSG.interpolateBetween2DPointsForY(activepolygon.topleft,activepolygon.bottomleft,nextycoordinate);var bottomleft=CSG.Vector2D.Create(x,nextycoordinate);x=CSG.interpolateBetween2DPointsForY(activepolygon.topright,activepolygon.bottomright,nextycoordinate);var bottomright=CSG.Vector2D.Create(x,nextycoordinate);var outpolygon={topleft:topleft,topright:topright,bottomleft:bottomleft,bottomright:bottomright,leftline:CSG.Line2D.fromPoints(topleft,bottomleft),rightline:CSG.Line2D.fromPoints(bottomright,topright)};if(newoutpolygonrow.length>0){var prevoutpolygon=newoutpolygonrow[newoutpolygonrow.length-1];var d1=outpolygon.topleft.distanceTo(prevoutpolygon.topright);var d2=outpolygon.bottomleft.distanceTo(prevoutpolygon.bottomright);if((d1<EPS)&&(d2<EPS)){outpolygon.topleft=prevoutpolygon.topleft;outpolygon.leftline=prevoutpolygon.leftline;outpolygon.bottomleft=prevoutpolygon.bottomleft;newoutpolygonrow.splice(newoutpolygonrow.length-1,1);}}
newoutpolygonrow.push(outpolygon);}
if(yindex>0){var prevcontinuedindexes={};var matchedindexes={};for(var i=0;i<newoutpolygonrow.length;i++){var thispolygon=newoutpolygonrow[i];for(var ii=0;ii<prevoutpolygonrow.length;ii++){if(!matchedindexes[ii])
{
 var prevpolygon=prevoutpolygonrow[ii];if(prevpolygon.bottomleft.distanceTo(thispolygon.topleft)<EPS){if(prevpolygon.bottomright.distanceTo(thispolygon.topright)<EPS){matchedindexes[ii]=true;var d1=thispolygon.leftline.direction().x-prevpolygon.leftline.direction().x;var d2=thispolygon.rightline.direction().x-prevpolygon.rightline.direction().x;var leftlinecontinues=Math.abs(d1)<EPS;var rightlinecontinues=Math.abs(d2)<EPS;var leftlineisconvex=leftlinecontinues||(d1>=0);var rightlineisconvex=rightlinecontinues||(d2>=0);if(leftlineisconvex&&rightlineisconvex){ thispolygon.outpolygon=prevpolygon.outpolygon;thispolygon.leftlinecontinues=leftlinecontinues;thispolygon.rightlinecontinues=rightlinecontinues;prevcontinuedindexes[ii]=true;}
break;}}}
}
} 
for(var ii=0;ii<prevoutpolygonrow.length;ii++){if(!prevcontinuedindexes[ii]){
var prevpolygon=prevoutpolygonrow[ii];prevpolygon.outpolygon.rightpoints.push(prevpolygon.bottomright);if(prevpolygon.bottomright.distanceTo(prevpolygon.bottomleft)>EPS){prevpolygon.outpolygon.leftpoints.push(prevpolygon.bottomleft);}
prevpolygon.outpolygon.leftpoints.reverse();var points2d=prevpolygon.outpolygon.rightpoints.concat(prevpolygon.outpolygon.leftpoints);var vertices3d=[];points2d.map(function(point2d){var point3d=orthobasis.to3D(point2d);var vertex3d=new CSG.Vertex(point3d);vertices3d.push(vertex3d);});var polygon=new CSG.Polygon(vertices3d,shared,plane);destpolygons.push(polygon);}}}
for(var i=0;i<newoutpolygonrow.length;i++){var thispolygon=newoutpolygonrow[i];if(!thispolygon.outpolygon){thispolygon.outpolygon={leftpoints:[],rightpoints:[]};thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);if(thispolygon.topleft.distanceTo(thispolygon.topright)>EPS){thispolygon.outpolygon.rightpoints.push(thispolygon.topright);}}else{ if(!thispolygon.leftlinecontinues){thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);}
if(!thispolygon.rightlinecontinues){thispolygon.outpolygon.rightpoints.push(thispolygon.topright);}}}
prevoutpolygonrow=newoutpolygonrow;}}
}
};







CSG.fuzzyFactory=function(numdimensions,tolerance){this.lookuptable={};this.multiplier=1.0/tolerance;};CSG.fuzzyFactory.prototype={

lookupOrCreate:function(els,creatorCallback){var hash="";var multiplier=this.multiplier;els.forEach(function(el){var valueQuantized=Math.round(el*multiplier);hash+=valueQuantized+"/";});if(hash in this.lookuptable)
{return this.lookuptable[hash];}
else
{var object=creatorCallback(els);var hashparts=els.map(function(el){var q0=Math.floor(el*multiplier);var q1=q0+1;return[""+q0+"/",""+q1+"/"];});var numelements=els.length;var numhashes=1<<numelements;for(var hashmask=0;hashmask<numhashes;++hashmask){var hashmask_shifted=hashmask;hash="";hashparts.forEach(function(hashpart){hash+=hashpart[hashmask_shifted&1];hashmask_shifted>>=1;});this.lookuptable[hash]=object;}
return object;}},};CSG.fuzzyCSGFactory=function(){this.vertexfactory=new CSG.fuzzyFactory(3,1e-5);this.planefactory=new CSG.fuzzyFactory(4,1e-5);this.polygonsharedfactory={};};CSG.fuzzyCSGFactory.prototype={getPolygonShared:function(sourceshared){var hash=sourceshared.getHash();if(hash in this.polygonsharedfactory){return this.polygonsharedfactory[hash];}else{this.polygonsharedfactory[hash]=sourceshared;return sourceshared;}},getVertex:function(sourcevertex){var elements=[sourcevertex.pos._x,sourcevertex.pos._y,sourcevertex.pos._z];var result=this.vertexfactory.lookupOrCreate(elements,function(els){return sourcevertex;});return result;},getPlane:function(sourceplane){var elements=[sourceplane.normal._x,sourceplane.normal._y,sourceplane.normal._z,sourceplane.w];var result=this.planefactory.lookupOrCreate(elements,function(els){return sourceplane;});return result;},getPolygon:function(sourcepolygon){var newplane=this.getPlane(sourcepolygon.plane);var newshared=this.getPolygonShared(sourcepolygon.shared);var _this=this;var newvertices=sourcepolygon.vertices.map(function(vertex){return _this.getVertex(vertex);});return new CSG.Polygon(newvertices,newshared,newplane);},getCSG:function(sourcecsg){var _this=this;var newpolygons=sourcecsg.polygons.map(function(polygon){return _this.getPolygon(polygon);});return CSG.fromPolygons(newpolygons);}};CSG.staticTag=1;CSG.getTag=function(){return CSG.staticTag++;};



CSG.Properties=function(){};CSG.Properties.prototype={_transform:function(matrix4x4){var result=new CSG.Properties();CSG.Properties.transformObj(this,result,matrix4x4);return result;},_merge:function(otherproperties){var result=new CSG.Properties();CSG.Properties.cloneObj(this,result);CSG.Properties.addFrom(result,otherproperties);return result;}};CSG.Properties.transformObj=function(source,result,matrix4x4){for(var propertyname in source){if(propertyname=="_transform")continue;if(propertyname=="_merge")continue;var propertyvalue=source[propertyname];var transformed=propertyvalue;if(typeof(propertyvalue)=="object"){if(('transform'in propertyvalue)&&(typeof(propertyvalue.transform)=="function")){transformed=propertyvalue.transform(matrix4x4);}else if(propertyvalue instanceof Array){transformed=[];CSG.Properties.transformObj(propertyvalue,transformed,matrix4x4);}else if(propertyvalue instanceof CSG.Properties){transformed=new CSG.Properties();CSG.Properties.transformObj(propertyvalue,transformed,matrix4x4);}}
result[propertyname]=transformed;}};CSG.Properties.cloneObj=function(source,result){for(var propertyname in source){if(propertyname=="_transform")continue;if(propertyname=="_merge")continue;var propertyvalue=source[propertyname];var cloned=propertyvalue;if(typeof(propertyvalue)=="object"){if(propertyvalue instanceof Array){cloned=[];for(var i=0;i<propertyvalue.length;i++){cloned.push(propertyvalue[i]);}}else if(propertyvalue instanceof CSG.Properties){cloned=new CSG.Properties();CSG.Properties.cloneObj(propertyvalue,cloned);}}
result[propertyname]=cloned;}};CSG.Properties.addFrom=function(result,otherproperties){for(var propertyname in otherproperties){if(propertyname=="_transform")continue;if(propertyname=="_merge")continue;if((propertyname in result)&&(typeof(result[propertyname])=="object")&&(result[propertyname]instanceof CSG.Properties)&&(typeof(otherproperties[propertyname])=="object")&&(otherproperties[propertyname]instanceof CSG.Properties)){CSG.Properties.addFrom(result[propertyname],otherproperties[propertyname]);}else if(!(propertyname in result)){result[propertyname]=otherproperties[propertyname];}}};



CSG.Connector=function(point,axisvector,normalvector){this.point=new CSG.Vector3D(point);this.axisvector=new CSG.Vector3D(axisvector).unit();this.normalvector=new CSG.Vector3D(normalvector).unit();};CSG.Connector.prototype={normalized:function(){var axisvector=this.axisvector.unit();var n=this.normalvector.cross(axisvector).unit();var normalvector=axisvector.cross(n);return new CSG.Connector(this.point,axisvector,normalvector);},transform:function(matrix4x4){var point=this.point.multiply4x4(matrix4x4);var axisvector=this.point.plus(this.axisvector).multiply4x4(matrix4x4).minus(point);var normalvector=this.point.plus(this.normalvector).multiply4x4(matrix4x4).minus(point);return new CSG.Connector(point,axisvector,normalvector);},




 getTransformationTo:function(other,mirror,normalrotation){mirror=mirror?true:false;normalrotation=normalrotation?Number(normalrotation):0;var us=this.normalized();other=other.normalized();var transformation=CSG.Matrix4x4.translation(this.point.negated());var axesplane=CSG.Plane.anyPlaneFromVector3Ds(new CSG.Vector3D(0,0,0),us.axisvector,other.axisvector);var axesbasis=new CSG.OrthoNormalBasis(axesplane);var angle1=axesbasis.to2D(us.axisvector).angle();var angle2=axesbasis.to2D(other.axisvector).angle();var rotation=180.0*(angle2-angle1)/Math.PI;if(mirror)rotation+=180.0;transformation=transformation.multiply(axesbasis.getProjectionMatrix());transformation=transformation.multiply(CSG.Matrix4x4.rotationZ(rotation));transformation=transformation.multiply(axesbasis.getInverseProjectionMatrix());var usAxesAligned=us.transform(transformation);var normalsplane=CSG.Plane.fromNormalAndPoint(other.axisvector,new CSG.Vector3D(0,0,0));var normalsbasis=new CSG.OrthoNormalBasis(normalsplane);angle1=normalsbasis.to2D(usAxesAligned.normalvector).angle();angle2=normalsbasis.to2D(other.normalvector).angle();rotation=180.0*(angle2-angle1)/Math.PI;rotation+=normalrotation;transformation=transformation.multiply(normalsbasis.getProjectionMatrix());transformation=transformation.multiply(CSG.Matrix4x4.rotationZ(rotation));transformation=transformation.multiply(normalsbasis.getInverseProjectionMatrix());transformation=transformation.multiply(CSG.Matrix4x4.translation(other.point));var usAligned=us.transform(transformation);return transformation;},axisLine:function(){return new CSG.Line3D(this.point,this.axisvector);}, extend:function(distance){var newpoint=this.point.plus(this.axisvector.unit().times(distance));return new CSG.Connector(newpoint,this.axisvector,this.normalvector);}};CSG.Path2D=function(points,closed){closed=!!closed;points=points||[];
 var prevpoint=null;if(closed&&(points.length>0)){prevpoint=new CSG.Vector2D(points[points.length-1]);}
var newpoints=[];points.map(function(point){point=new CSG.Vector2D(point);var skip=false;if(prevpoint!==null){var distance=point.distanceTo(prevpoint);skip=distance<1e-5;}
if(!skip)newpoints.push(point);prevpoint=point;});this.points=newpoints;this.closed=closed;};CSG.Path2D.arc=function(options){var center=CSG.parseOptionAs2DVector(options,"center",0);var radius=CSG.parseOptionAsFloat(options,"radius",1);var startangle=CSG.parseOptionAsFloat(options,"startangle",0);var endangle=CSG.parseOptionAsFloat(options,"endangle",360);var resolution=CSG.parseOptionAsFloat(options,"resolution",CSG.defaultResolution2D);var maketangent=CSG.parseOptionAsBool(options,"maketangent",false);while(endangle-startangle>=720){endangle-=360;}
while(endangle-startangle<=-720){endangle+=360;}
var points=[],point;var absangledif=Math.abs(endangle-startangle);if(absangledif<1e-5){point=CSG.Vector2D.fromAngle(startangle/180.0*Math.PI).times(radius);points.push(point.plus(center));}else{var numsteps=Math.floor(resolution*absangledif/360)+1;var edgestepsize=numsteps*0.5/absangledif; if(edgestepsize>0.25)edgestepsize=0.25;var numsteps_mod=maketangent?(numsteps+2):numsteps;for(var i=0;i<=numsteps_mod;i++){var step=i;if(maketangent){step=(i-1)*(numsteps-2*edgestepsize)/numsteps+edgestepsize;if(step<0)step=0;if(step>numsteps)step=numsteps;}
var angle=startangle+step*(endangle-startangle)/numsteps;point=CSG.Vector2D.fromAngle(angle/180.0*Math.PI).times(radius);points.push(point.plus(center));}}
return new CSG.Path2D(points,false);};CSG.Path2D.prototype={concat:function(otherpath){if(this.closed||otherpath.closed){throw new Error("Paths must not be closed");}
var newpoints=this.points.concat(otherpath.points);return new CSG.Path2D(newpoints);},appendPoint:function(point){if(this.closed){throw new Error("Path must not be closed");}
point=new CSG.Vector2D(point); var newpoints=this.points.concat([point]);return new CSG.Path2D(newpoints);},appendPoints:function(points){if(this.closed){throw new Error("Path must not be closed");}
var newpoints=this.points;points.forEach(function(point){newpoints.push(new CSG.Vector2D(point));})
return new CSG.Path2D(newpoints);},close:function(){return new CSG.Path2D(this.points,true);},


 
rectangularExtrude:function(width,height,resolution){var cag=this.expandToCAG(width/2,resolution);var result=cag.extrude({offset:[0,0,height]});return result;},
 expandToCAG:function(pathradius,resolution){var sides=[];var numpoints=this.points.length;var startindex=0;if(this.closed&&(numpoints>2))startindex=-1;var prevvertex;for(var i=startindex;i<numpoints;i++){var pointindex=i;if(pointindex<0)pointindex=numpoints-1;var point=this.points[pointindex];var vertex=new CAG.Vertex(point);if(i>startindex){var side=new CAG.Side(prevvertex,vertex);sides.push(side);}
prevvertex=vertex;}
var shellcag=CAG.fromSides(sides);var expanded=shellcag.expandedShell(pathradius,resolution);return expanded;},innerToCAG:function(){if(!this.closed)throw new Error("The path should be closed!");return CAG.fromPoints(this.points);},transform:function(matrix4x4){var newpoints=this.points.map(function(point){return point.multiply4x4(matrix4x4);});return new CSG.Path2D(newpoints,this.closed);},appendBezier:function(controlpoints,options){if(arguments.length<2)
{options={};}
if(this.closed){throw new Error("Path must not be closed");}
if(!(controlpoints instanceof Array))
{throw new Error("appendBezier: should pass an array of control points")}
if(controlpoints.length<1)
{throw new Error("appendBezier: need at least 1 control point")}
if(this.points.length<1){throw new Error("appendBezier: path must already contain a point (the endpoint of the path is used as the starting point for the bezier curve)");}
var resolution=CSG.parseOptionAsInt(options,"resolution",CSG.defaultResolution2D);if(resolution<4)resolution=4;var factorials=[];var controlpoints_parsed=[];controlpoints_parsed.push(this.points[this.points.length-1]); for(var i=0;i<controlpoints.length;++i){var p=controlpoints[i];if(p===null)
{if(i!=0)
{throw new Error("appendBezier: null can only be passed as the first control point");}
if(controlpoints.length<2)
{throw new Error("appendBezier: null can only be passed if there is at least one more control point");}
var lastBezierControlPoint;if('lastBezierControlPoint'in this)
{lastBezierControlPoint=this.lastBezierControlPoint;}
else
{if(this.points.length<2)
{throw new Error("appendBezier: null is passed as a control point but this requires a previous bezier curve or at least two points in the existing path");}
lastBezierControlPoint=this.points[this.points.length-2];}
p=this.points[this.points.length-1].times(2).minus(lastBezierControlPoint);}
else
{p=new CSG.Vector2D(p);}
controlpoints_parsed.push(p);}
var bezier_order=controlpoints_parsed.length-1;var fact=1;for(var i=0;i<=bezier_order;++i){if(i>0)fact*=i;factorials.push(fact);}
var binomials=[];for(var i=0;i<=bezier_order;++i){var binomial=factorials[bezier_order]/(factorials[i]*factorials[bezier_order-i]);binomials.push(binomial);}
var getPointForT=function(t)
{var t_k=1;var one_minus_t_n_minus_k=Math.pow(1-t,bezier_order);var inv_1_minus_t=(t!=1)?(1/(1-t)):1;var point=new CSG.Vector2D(0,0);for(var k=0;k<=bezier_order;++k){if(k==bezier_order)one_minus_t_n_minus_k=1;var bernstein_coefficient=binomials[k]*t_k*one_minus_t_n_minus_k;point=point.plus(controlpoints_parsed[k].times(bernstein_coefficient));t_k*=t;one_minus_t_n_minus_k*=inv_1_minus_t;}
return point;};var newpoints=[];var newpoints_t=[];var numsteps=bezier_order+1;for(var i=0;i<numsteps;++i){var t=i/(numsteps-1);var point=getPointForT(t);newpoints.push(point);newpoints_t.push(t);}
var subdivide_base=1;var maxangle=Math.PI*2/resolution; var maxsinangle=Math.sin(maxangle);while(subdivide_base<newpoints.length-1)
{var dir1=newpoints[subdivide_base].minus(newpoints[subdivide_base-1]).unit();var dir2=newpoints[subdivide_base+1].minus(newpoints[subdivide_base]).unit();var sinangle=dir1.cross(dir2); if(Math.abs(sinangle)>maxsinangle)
{ var t0=newpoints_t[subdivide_base-1];var t1=newpoints_t[subdivide_base+1];var t0_new=t0+(t1-t0)*1/3;var t1_new=t0+(t1-t0)*2/3;var point0_new=getPointForT(t0_new);var point1_new=getPointForT(t1_new);newpoints.splice(subdivide_base,1,point0_new,point1_new);newpoints_t.splice(subdivide_base,1,t0_new,t1_new);subdivide_base--;if(subdivide_base<1)subdivide_base=1;}
else
{++subdivide_base;}}
newpoints=this.points.concat(newpoints.slice(1));var result=new CSG.Path2D(newpoints);result.lastBezierControlPoint=controlpoints_parsed[controlpoints_parsed.length-2];return result;},appendArc:function(endpoint,options){if(arguments.length<2)
{options={};}
if(this.closed){throw new Error("Path must not be closed");}
if(this.points.length<1){throw new Error("appendArc: path must already contain a point (the endpoint of the path is used as the starting point for the arc)");}
var resolution=CSG.parseOptionAsInt(options,"resolution",CSG.defaultResolution2D);if(resolution<4)resolution=4;var xradius,yradius;if(('xradius'in options)||('yradius'in options))
{if('radius'in options)
{throw new Error("Should either give an xradius and yradius parameter, or a radius parameter");}
xradius=CSG.parseOptionAsFloat(options,"xradius",0);yradius=CSG.parseOptionAsFloat(options,"yradius",0);}
else
{xradius=CSG.parseOptionAsFloat(options,"radius",0);yradius=xradius;}
var xaxisrotation=CSG.parseOptionAsFloat(options,"xaxisrotation",0);var clockwise=CSG.parseOptionAsBool(options,"clockwise",false);var largearc=CSG.parseOptionAsBool(options,"large",false);var startpoint=this.points[this.points.length-1];endpoint=new CSG.Vector2D(endpoint);var sweep_flag=!clockwise;var newpoints=[];if((xradius==0)||(yradius==0))
{ newpoints.push(endpoint);}
else
{xradius=Math.abs(xradius);yradius=Math.abs(yradius);var phi=xaxisrotation*Math.PI/180.0;var cosphi=Math.cos(phi);var sinphi=Math.sin(phi);var minushalfdistance=startpoint.minus(endpoint).times(0.5);var start_translated=new CSG.Vector2D(cosphi*minushalfdistance.x+sinphi*minushalfdistance.y,-sinphi*minushalfdistance.x+cosphi*minushalfdistance.y);var biglambda=start_translated.x*start_translated.x/(xradius*xradius)+start_translated.y*start_translated.y/(yradius*yradius);if(biglambda>1)
{var sqrtbiglambda=Math.sqrt(biglambda);xradius*=sqrtbiglambda;yradius*=sqrtbiglambda;}
var multiplier1=Math.sqrt((xradius*xradius*yradius*yradius-xradius*xradius*start_translated.y*start_translated.y-yradius*yradius*start_translated.x*start_translated.x)/(xradius*xradius*start_translated.y*start_translated.y+yradius*yradius*start_translated.x*start_translated.x));if(sweep_flag==largearc)multiplier1=-multiplier1;var center_translated=new CSG.Vector2D(xradius*start_translated.y/yradius,-yradius*start_translated.x/xradius).times(multiplier1);var center=new CSG.Vector2D(cosphi*center_translated.x-sinphi*center_translated.y,sinphi*center_translated.x+cosphi*center_translated.y).plus((startpoint.plus(endpoint)).times(0.5));var vec1=new CSG.Vector2D((start_translated.x-center_translated.x)/xradius,(start_translated.y-center_translated.y)/yradius);var vec2=new CSG.Vector2D((-start_translated.x-center_translated.x)/xradius,(-start_translated.y-center_translated.y)/yradius);var theta1=vec1.angleRadians();var theta2=vec2.angleRadians();var deltatheta=theta2-theta1;deltatheta=deltatheta%(2*Math.PI);if((!sweep_flag)&&(deltatheta>0))
{deltatheta-=2*Math.PI;}
else if((sweep_flag)&&(deltatheta<0))
{deltatheta+=2*Math.PI;} 
var numsteps=Math.ceil(Math.abs(deltatheta)/(2*Math.PI)*resolution)+1;if(numsteps<1)numsteps=1;for(var step=1;step<=numsteps;step++)
{var theta=theta1+step/numsteps*deltatheta;var costheta=Math.cos(theta);var sintheta=Math.sin(theta);var point=new CSG.Vector2D(cosphi*xradius*costheta-sinphi*yradius*sintheta,sinphi*xradius*costheta+cosphi*yradius*sintheta).plus(center);newpoints.push(point);}}
newpoints=this.points.concat(newpoints);var result=new CSG.Path2D(newpoints);return result;},};CSG.addTransformationMethodsToPrototype=function(prot){prot.mirrored=function(plane){return this.transform(CSG.Matrix4x4.mirroring(plane));};prot.mirroredX=function(){var plane=new CSG.Plane(CSG.Vector3D.Create(1,0,0),0);return this.mirrored(plane);};prot.mirroredY=function(){var plane=new CSG.Plane(CSG.Vector3D.Create(0,1,0),0);return this.mirrored(plane);};prot.mirroredZ=function(){var plane=new CSG.Plane(CSG.Vector3D.Create(0,0,1),0);return this.mirrored(plane);};prot.translate=function(v){return this.transform(CSG.Matrix4x4.translation(v));};prot.scale=function(f){return this.transform(CSG.Matrix4x4.scaling(f));};prot.rotateX=function(deg){return this.transform(CSG.Matrix4x4.rotationX(deg));};prot.rotateY=function(deg){return this.transform(CSG.Matrix4x4.rotationY(deg));};prot.rotateZ=function(deg){return this.transform(CSG.Matrix4x4.rotationZ(deg));};prot.rotate=function(rotationCenter,rotationAxis,degrees){return this.transform(CSG.Matrix4x4.rotation(rotationCenter,rotationAxis,degrees));};};

var CAG=function(){this.sides=[];};CAG.fromSides=function(sides){var cag=new CAG();cag.sides=sides;return cag;};
CAG.fromPoints=function(points){var numpoints=points.length;if(numpoints<3)throw new Error("CAG shape needs at least 3 points");var sides=[];var prevpoint=new CSG.Vector2D(points[numpoints-1]);var prevvertex=new CAG.Vertex(prevpoint);points.map(function(p){var point=new CSG.Vector2D(p);var vertex=new CAG.Vertex(point);var side=new CAG.Side(prevvertex,vertex);sides.push(side);prevvertex=vertex;});var result=CAG.fromSides(sides);if(result.isSelfIntersecting()){throw new Error("Polygon is self intersecting!");}
var area=result.area();if(Math.abs(area)<1e-5){throw new Error("Degenerate polygon!");}
if(area<0){result=result.flipped();}
result=result.canonicalized();return result;};CAG.fromPointsNoCheck=function(points){var sides=[];var prevpoint=new CSG.Vector2D(points[points.length-1]);var prevvertex=new CAG.Vertex(prevpoint);points.map(function(p){var point=new CSG.Vector2D(p);var vertex=new CAG.Vertex(point);var side=new CAG.Side(prevvertex,vertex);sides.push(side);prevvertex=vertex;});return CAG.fromSides(sides);};
CAG.fromFakeCSG=function(csg){var sides=csg.polygons.map(function(p){return CAG.Side.fromFakePolygon(p);});return CAG.fromSides(sides);};
CAG.linesIntersect=function(p0start,p0end,p1start,p1end){if(p0end.equals(p1start)||p1end.equals(p0start)){var d=p1end.minus(p1start).unit().plus(p0end.minus(p0start).unit()).length();if(d<1e-5){return true;}}else{var d0=p0end.minus(p0start);var d1=p1end.minus(p1start);if(Math.abs(d0.cross(d1))<1e-9)return false; var alphas=CSG.solve2Linear(-d0.x,d1.x,-d0.y,d1.y,p0start.x-p1start.x,p0start.y-p1start.y);if((alphas[0]>1e-6)&&(alphas[0]<0.999999)&&(alphas[1]>1e-5)&&(alphas[1]<0.999999))return true;}
return false;};CAG.circle=function(options){options=options||{};var center=CSG.parseOptionAs2DVector(options,"center",[0,0]);var radius=CSG.parseOptionAsFloat(options,"radius",1);var resolution=CSG.parseOptionAsInt(options,"resolution",CSG.defaultResolution2D);var sides=[];var prevvertex;for(var i=0;i<=resolution;i++){var radians=2*Math.PI*i/resolution;var point=CSG.Vector2D.fromAngleRadians(radians).times(radius).plus(center);var vertex=new CAG.Vertex(point);if(i>0){sides.push(new CAG.Side(prevvertex,vertex));}
prevvertex=vertex;}
return CAG.fromSides(sides);};CAG.rectangle=function(options){options=options||{};var c,r;if(('corner1'in options)||('corner2'in options))
{if(('center'in options)||('radius'in options))
{throw new Error("rectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter")}
corner1=CSG.parseOptionAs2DVector(options,"corner1",[0,0]);corner2=CSG.parseOptionAs2DVector(options,"corner2",[1,1]);c=corner1.plus(corner2).times(0.5);r=corner2.minus(corner1).times(0.5);}
else
{c=CSG.parseOptionAs2DVector(options,"center",[0,0]);r=CSG.parseOptionAs2DVector(options,"radius",[1,1]);}
r=r.abs(); var rswap=new CSG.Vector2D(r.x,-r.y);var points=[c.plus(r),c.plus(rswap),c.minus(r),c.minus(rswap)];return CAG.fromPoints(points);};CAG.roundedRectangle=function(options){options=options||{};var center,radius;if(('corner1'in options)||('corner2'in options))
{if(('center'in options)||('radius'in options))
{throw new Error("roundedRectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter")}
corner1=CSG.parseOptionAs2DVector(options,"corner1",[0,0]);corner2=CSG.parseOptionAs2DVector(options,"corner2",[1,1]);center=corner1.plus(corner2).times(0.5);radius=corner2.minus(corner1).times(0.5);}
else
{center=CSG.parseOptionAs2DVector(options,"center",[0,0]);radius=CSG.parseOptionAs2DVector(options,"radius",[1,1]);}
radius=radius.abs(); var roundradius=CSG.parseOptionAsFloat(options,"roundradius",0.2);var resolution=CSG.parseOptionAsFloat(options,"resolution",CSG.defaultResolution2D);var maxroundradius=Math.min(radius.x,radius.y);maxroundradius-=0.1;roundradius=Math.min(roundradius,maxroundradius);roundradius=Math.max(0,roundradius);radius=new CSG.Vector2D(radius.x-roundradius,radius.y-roundradius);var rect=CAG.rectangle({center:center,radius:radius});if(roundradius>0){rect=rect.expand(roundradius,resolution);}
return rect;};CAG.fromCompactBinary=function(bin){if(bin['class']!="CAG")throw new Error("Not a CAG");var vertices=[];var vertexData=bin.vertexData;var numvertices=vertexData.length/2;var arrayindex=0;for(var vertexindex=0;vertexindex<numvertices;vertexindex++){var x=vertexData[arrayindex++];var y=vertexData[arrayindex++];var pos=new CSG.Vector2D(x,y);var vertex=new CAG.Vertex(pos);vertices.push(vertex);}
var sides=[];var numsides=bin.sideVertexIndices.length/2;arrayindex=0;for(var sideindex=0;sideindex<numsides;sideindex++){var vertexindex0=bin.sideVertexIndices[arrayindex++];var vertexindex1=bin.sideVertexIndices[arrayindex++];var side=new CAG.Side(vertices[vertexindex0],vertices[vertexindex1]);sides.push(side);}
var cag=CAG.fromSides(sides);cag.isCanonicalized=true;return cag;};function fnSortByIndex(a,b){return a.index-b.index;}
CAG.prototype={toString:function(){var result="CAG ("+this.sides.length+" sides):\n";this.sides.map(function(side){result+="  "+side.toString()+"\n";});return result;},toCSG:function(z0,z1){var polygons=this.sides.map(function(side){return side.toPolygon3D(z0,z1);});return CSG.fromPolygons(polygons);},toDebugString1:function(){this.sides.sort(function(a,b){return a.vertex0.pos.x-b.vertex0.pos.x;});var str="";this.sides.map(function(side){str+="("+side.vertex0.pos.x+","+side.vertex0.pos.y+") - ("+side.vertex1.pos.x+","+side.vertex1.pos.y+")\n";});return str;},toDebugString:function(){var str="CAG.fromSides([\n";this.sides.map(function(side){str+="  new CAG.Side(new CAG.Vertex(new CSG.Vector2D("+
side.vertex0.pos.x+","+side.vertex0.pos.y+")), new CAG.Vertex(new CSG.Vector2D("+
side.vertex1.pos.x+","+side.vertex1.pos.y+"))),\n";});str+="]);\n";return str;},union:function(cag){var cags;if(cag instanceof Array){cags=cag;}else{cags=[cag];}
var r=this.toCSG(-1,1);cags.map(function(cag){r=r.unionSub(cag.toCSG(-1,1),false,false);});r=r.reTesselated();r=r.canonicalized();cag=CAG.fromFakeCSG(r);var cag_canonicalized=cag.canonicalized();return cag_canonicalized;},subtract:function(cag){var cags;if(cag instanceof Array){cags=cag;}else{cags=[cag];}
var r=this.toCSG(-1,1);cags.map(function(cag){r=r.subtractSub(cag.toCSG(-1,1),false,false);});r=r.reTesselated();r=r.canonicalized();r=CAG.fromFakeCSG(r);r=r.canonicalized();return r;},intersect:function(cag){var cags;if(cag instanceof Array){cags=cag;}else{cags=[cag];}
var r=this.toCSG(-1,1);cags.map(function(cag){r=r.intersectSub(cag.toCSG(-1,1),false,false);});r=r.reTesselated();r=r.canonicalized();r=CAG.fromFakeCSG(r);r=r.canonicalized();return r;},transform:function(matrix4x4){var ismirror=matrix4x4.isMirroring();var newsides=this.sides.map(function(side){return side.transform(matrix4x4);});var result=CAG.fromSides(newsides);if(ismirror){result=result.flipped();}
return result;}, area:function(){var polygonArea=0;this.sides.map(function(side){polygonArea+=side.vertex0.pos.cross(side.vertex1.pos);});polygonArea*=0.5;return polygonArea;},flipped:function(){var newsides=this.sides.map(function(side){return side.flipped();});newsides.reverse();return CAG.fromSides(newsides);},getBounds:function(){var minpoint;if(this.sides.length===0){minpoint=new CSG.Vector2D(0,0);}else{minpoint=this.sides[0].vertex0.pos;}
var maxpoint=minpoint;this.sides.map(function(side){minpoint=minpoint.min(side.vertex0.pos);minpoint=minpoint.min(side.vertex1.pos);maxpoint=maxpoint.max(side.vertex0.pos);maxpoint=maxpoint.max(side.vertex1.pos);});return[minpoint,maxpoint];},isSelfIntersecting:function(){var numsides=this.sides.length;for(var i=0;i<numsides;i++){var side0=this.sides[i];for(var ii=i+1;ii<numsides;ii++){var side1=this.sides[ii];if(CAG.linesIntersect(side0.vertex0.pos,side0.vertex1.pos,side1.vertex0.pos,side1.vertex1.pos)){return true;}}}
return false;},expandedShell:function(radius,resolution){resolution=resolution||8;if(resolution<4)resolution=4;var cags=[];var pointmap={};var cag=this.canonicalized();cag.sides.map(function(side){var d=side.vertex1.pos.minus(side.vertex0.pos);var dl=d.length();if(dl>1e-5){d=d.times(1.0/dl);var normal=d.normal().times(radius);var shellpoints=[side.vertex1.pos.plus(normal),side.vertex1.pos.minus(normal),side.vertex0.pos.minus(normal),side.vertex0.pos.plus(normal)];var newcag=CAG.fromPoints(shellpoints);cags.push(newcag);for(var step=0;step<2;step++){var p1=(step===0)?side.vertex0.pos:side.vertex1.pos;var p2=(step===0)?side.vertex1.pos:side.vertex0.pos;var tag=p1.x+" "+p1.y;if(!(tag in pointmap)){pointmap[tag]=[];}
pointmap[tag].push({"p1":p1,"p2":p2});}}});for(var tag in pointmap){var m=pointmap[tag];var angle1,angle2;var pcenter=m[0].p1;if(m.length==2){var end1=m[0].p2;var end2=m[1].p2;angle1=end1.minus(pcenter).angleDegrees();angle2=end2.minus(pcenter).angleDegrees();if(angle2<angle1)angle2+=360;if(angle2>=(angle1+360))angle2-=360;if(angle2<angle1+180){var t=angle2;angle2=angle1+360;angle1=t;}
angle1+=90;angle2-=90;}else{angle1=0;angle2=360;}
var fullcircle=(angle2>angle1+359.999);if(fullcircle){angle1=0;angle2=360;}
if(angle2>(angle1+1e-5)){var points=[];if(!fullcircle){points.push(pcenter);}
var numsteps=Math.round(resolution*(angle2-angle1)/360);if(numsteps<1)numsteps=1;for(var step=0;step<=numsteps;step++){var angle=angle1+step/numsteps*(angle2-angle1);if(step==numsteps)angle=angle2; var point=pcenter.plus(CSG.Vector2D.fromAngleDegrees(angle).times(radius));if((!fullcircle)||(step>0)){points.push(point);}}
var newcag=CAG.fromPointsNoCheck(points);cags.push(newcag);}}
var result=new CAG();result=result.union(cags);return result;},expand:function(radius,resolution){var result=this.union(this.expandedShell(radius,resolution));return result;},contract:function(radius,resolution){var result=this.subtract(this.expandedShell(radius,resolution));return result;},

extrudeInOrthonormalBasis:function(orthonormalbasis,depth){if(!(orthonormalbasis instanceof CSG.OrthoNormalBasis))
{throw new Error("extrudeInPlane: the first parameter should be a CSG.OrthoNormalBasis");}
var extruded=this.extrude({offset:[0,0,depth]}).translate([0,0,-depth/2]);var matrix=orthonormalbasis.getInverseProjectionMatrix();extruded=extruded.transform(matrix);return extruded;},

extrudeInPlane:function(axis1,axis2,depth){return this.extrudeInOrthonormalBasis(CSG.OrthoNormalBasis.GetCartesian(axis1,axis2),depth);},
 
extrude:function(options){if(this.sides.length==0){return new CSG();}
var offsetvector=CSG.parseOptionAs3DVector(options,"offset",[0,0,1]);var twistangle=CSG.parseOptionAsFloat(options,"twistangle",0);var twiststeps=CSG.parseOptionAsInt(options,"twiststeps",10);if(twistangle==0)twiststeps=1;if(twiststeps<1)twiststeps=1;var newpolygons=[];var prevtransformedcag;var prevstepz;for(var step=0;step<=twiststeps;step++){var stepfraction=step/twiststeps;var transformedcag=this;var angle=twistangle*stepfraction;if(angle!=0){transformedcag=transformedcag.rotateZ(angle);}
var translatevector=new CSG.Vector2D(offsetvector.x,offsetvector.y).times(stepfraction);transformedcag=transformedcag.translate(translatevector);var bounds=transformedcag.getBounds();bounds[0]=bounds[0].minus(new CSG.Vector2D(1,1));bounds[1]=bounds[1].plus(new CSG.Vector2D(1,1));var stepz=offsetvector.z*stepfraction;if((step==0)||(step==twiststeps)){var csgshell=transformedcag.toCSG(stepz-1,stepz+1);var csgplane=CSG.fromPolygons([new CSG.Polygon([new CSG.Vertex(new CSG.Vector3D(bounds[0].x,bounds[0].y,stepz)),new CSG.Vertex(new CSG.Vector3D(bounds[1].x,bounds[0].y,stepz)),new CSG.Vertex(new CSG.Vector3D(bounds[1].x,bounds[1].y,stepz)),new CSG.Vertex(new CSG.Vector3D(bounds[0].x,bounds[1].y,stepz))])]);var flip=(step==0);if(offsetvector.z<0)flip=!flip;if(flip){csgplane=csgplane.inverse();}
csgplane=csgplane.intersect(csgshell);csgplane.polygons.map(function(polygon){if(Math.abs(polygon.plane.normal.z)>0.99){newpolygons.push(polygon);}});}
if(step>0){var numsides=transformedcag.sides.length;for(var sideindex=0;sideindex<numsides;sideindex++){var thisside=transformedcag.sides[sideindex];var prevside=prevtransformedcag.sides[sideindex];var p1=new CSG.Polygon([new CSG.Vertex(thisside.vertex1.pos.toVector3D(stepz)),new CSG.Vertex(thisside.vertex0.pos.toVector3D(stepz)),new CSG.Vertex(prevside.vertex0.pos.toVector3D(prevstepz))]);var p2=new CSG.Polygon([new CSG.Vertex(thisside.vertex1.pos.toVector3D(stepz)),new CSG.Vertex(prevside.vertex0.pos.toVector3D(prevstepz)),new CSG.Vertex(prevside.vertex1.pos.toVector3D(prevstepz))]);if(offsetvector.z<0){p1=p1.flipped();p2=p2.flipped();}
newpolygons.push(p1);newpolygons.push(p2);}}
prevtransformedcag=transformedcag;prevstepz=stepz;} 
return CSG.fromPolygons(newpolygons);},check:function(){var errors=[];if(this.isSelfIntersecting()){errors.push("Self intersects");}
var pointcount={};this.sides.map(function(side){function mappoint(p){var tag=p.x+" "+p.y;if(!(tag in pointcount))pointcount[tag]=0;pointcount[tag]++;}
mappoint(side.vertex0.pos);mappoint(side.vertex1.pos);});for(var tag in pointcount){var count=pointcount[tag];if(count&1){errors.push("Uneven number of sides ("+count+") for point "+tag);}}
var area=this.area();if(area<1e-5){errors.push("Area is "+area);}
if(errors.length>0){var ertxt="";errors.map(function(err){ertxt+=err+"\n";});throw new Error(ertxt);}},canonicalized:function(){if(this.isCanonicalized){return this;}else{var factory=new CAG.fuzzyCAGFactory();var result=factory.getCAG(this);result.isCanonicalized=true;return result;}},toCompactBinary:function(){var cag=this.canonicalized();var numsides=cag.sides.length;var vertexmap={};var vertices=[];var numvertices=0;var sideVertexIndices=new Uint32Array(2*numsides);var sidevertexindicesindex=0;cag.sides.map(function(side){[side.vertex0,side.vertex1].map(function(v){var vertextag=v.getTag();var vertexindex;if(!(vertextag in vertexmap)){vertexindex=numvertices++;vertexmap[vertextag]=vertexindex;vertices.push(v);}else{vertexindex=vertexmap[vertextag];}
sideVertexIndices[sidevertexindicesindex++]=vertexindex;});});var vertexData=new Float64Array(numvertices*2);var verticesArrayIndex=0;vertices.map(function(v){var pos=v.pos;vertexData[verticesArrayIndex++]=pos._x;vertexData[verticesArrayIndex++]=pos._y;});var result={'class':"CAG",sideVertexIndices:sideVertexIndices,vertexData:vertexData};return result;},getOutlinePaths:function(){var cag=this.canonicalized();var sideTagToSideMap={};var startVertexTagToSideTagMap={};cag.sides.map(function(side){var sidetag=side.getTag();sideTagToSideMap[sidetag]=side;var startvertextag=side.vertex0.getTag();if(!(startvertextag in startVertexTagToSideTagMap)){startVertexTagToSideTagMap[startvertextag]=[];}
startVertexTagToSideTagMap[startvertextag].push(sidetag);});var paths=[];while(true){var startsidetag=null;for(var aVertexTag in startVertexTagToSideTagMap){var sidesForThisVertex=startVertexTagToSideTagMap[aVertexTag];startsidetag=sidesForThisVertex[0];sidesForThisVertex.splice(0,1);if(sidesForThisVertex.length===0){delete startVertexTagToSideTagMap[aVertexTag];}
break;}
if(startsidetag===null)break; var connectedVertexPoints=[];var sidetag=startsidetag;var thisside=sideTagToSideMap[sidetag];var startvertextag=thisside.vertex0.getTag();while(true){connectedVertexPoints.push(thisside.vertex0.pos);var nextvertextag=thisside.vertex1.getTag();if(nextvertextag==startvertextag)break; if(!(nextvertextag in startVertexTagToSideTagMap)){throw new Error("Area is not closed!");}
var nextpossiblesidetags=startVertexTagToSideTagMap[nextvertextag];var nextsideindex=-1;if(nextpossiblesidetags.length==1){nextsideindex=0;}else{
 var bestangle=null;var thisangle=thisside.direction().angleDegrees();for(var sideindex=0;sideindex<nextpossiblesidetags.length;sideindex++){var nextpossiblesidetag=nextpossiblesidetags[sideindex];var possibleside=sideTagToSideMap[nextpossiblesidetag];var angle=possibleside.direction().angleDegrees();var angledif=angle-thisangle;if(angledif<-180)angledif+=360;if(angledif>=180)angledif-=360;if((nextsideindex<0)||(angledif>bestangle)){nextsideindex=sideindex;bestangle=angledif;}}}
var nextsidetag=nextpossiblesidetags[nextsideindex];nextpossiblesidetags.splice(nextsideindex,1);if(nextpossiblesidetags.length===0){delete startVertexTagToSideTagMap[nextvertextag];}
thisside=sideTagToSideMap[nextsidetag];} 
var path=new CSG.Path2D(connectedVertexPoints,true);paths.push(path);} 
return paths;},toDxf:function(){var paths=this.getOutlinePaths();return CAG.PathsToDxf(paths);},overCutInsideCorners:function(cutterradius){var cag=this.canonicalized();var pointmap={};cag.sides.map(function(side){if(!(side.vertex0.getTag()in pointmap))
{pointmap[side.vertex0.getTag()]={pos:side.vertex0.pos,from:[],to:[]};}
pointmap[side.vertex0.getTag()].to.push(side.vertex1.pos);if(!(side.vertex1.getTag()in pointmap))
{pointmap[side.vertex1.getTag()]={pos:side.vertex1.pos,from:[],to:[]};}
pointmap[side.vertex1.getTag()].from.push(side.vertex0.pos);});var cutouts=[];for(var pointtag in pointmap)
{var pointobj=pointmap[pointtag];if((pointobj.from.length==1)&&(pointobj.to.length==1))
{var fromcoord=pointobj.from[0];var pointcoord=pointobj.pos;var tocoord=pointobj.to[0];var v1=pointcoord.minus(fromcoord).unit();var v2=tocoord.minus(pointcoord).unit();var crossproduct=v1.cross(v2);var isInnerCorner=(crossproduct<0.001);if(isInnerCorner)
{var alpha=v2.angleRadians()-v1.angleRadians()+Math.PI;if(alpha<0)
{alpha+=2*Math.PI;}
else if(alpha>=2*Math.PI)
{alpha-=2*Math.PI;}
var midvector=v2.minus(v1).unit();var circlesegmentangle=30/180*Math.PI;
 var radiuscorrected=cutterradius/Math.cos(circlesegmentangle/2);var circlecenter=pointcoord.plus(midvector.times(radiuscorrected));var startangle=alpha+midvector.angleRadians();var deltaangle=2*(Math.PI-alpha);var numsteps=2*Math.ceil(deltaangle/circlesegmentangle/2);
var points=[circlecenter];for(var i=0;i<=numsteps;i++)
{var angle=startangle+i/numsteps*deltaangle;var p=CSG.Vector2D.fromAngleRadians(angle).times(radiuscorrected).plus(circlecenter);points.push(p);}
cutouts.push(CAG.fromPoints(points));}}}
var result=cag.subtract(cutouts);return result;}};CAG.PathsToDxf=function(paths){var str="999\nDXF generated by OpenJsCad\n";str+="  0\nSECTION\n  2\nHEADER\n";str+="  0\nENDSEC\n";str+="  0\nSECTION\n  2\nTABLES\n";str+="  0\nTABLE\n  2\nLTYPE\n  70\n1\n";str+="  0\nLTYPE\n  2\nCONTINUOUS\n  3\nSolid Line\n  72\n65\n  73\n0\n  40\n0.0\n";str+="  0\nENDTAB\n";str+="  0\nTABLE\n  2\nLAYER\n  70\n1\n";str+="  0\nLAYER\n  2\nOpenJsCad\n  62\n7\n  6\ncontinuous\n";str+="  0\nENDTAB\n";str+="  0\nTABLE\n  2\nSTYLE\n  70\n0\n  0\nENDTAB\n";str+="  0\nTABLE\n  2\nVIEW\n  70\n0\n  0\nENDTAB\n";str+="  0\nENDSEC\n";str+="  0\nSECTION\n  2\nBLOCKS\n";str+="  0\nENDSEC\n";str+="  0\nSECTION\n  2\nENTITIES\n";paths.map(function(path){var numpoints_closed=path.points.length+(path.closed?1:0);str+="  0\nLWPOLYLINE\n  8\nOpenJsCad\n  90\n"+numpoints_closed+"\n  70\n"+(path.closed?1:0)+"\n";for(var pointindex=0;pointindex<numpoints_closed;pointindex++){var pointindexwrapped=pointindex;if(pointindexwrapped>=path.points.length)pointindexwrapped-=path.points.length;var point=path.points[pointindexwrapped];str+=" 10\n"+point.x+"\n 20\n"+point.y+"\n 30\n0.0\n";}});str+="  0\nENDSEC\n  0\nEOF\n";return new Blob([str],{type:"application/dxf"});};CAG.Vertex=function(pos){this.pos=pos;};CAG.Vertex.prototype={toString:function(){return"("+this.pos.x.toFixed(2)+","+this.pos.y.toFixed(2)+")";},getTag:function(){var result=this.tag;if(!result){result=CSG.getTag();this.tag=result;}
return result;}};CAG.Side=function(vertex0,vertex1){if(!(vertex0 instanceof CAG.Vertex))throw new Error("Assertion failed");if(!(vertex1 instanceof CAG.Vertex))throw new Error("Assertion failed");this.vertex0=vertex0;this.vertex1=vertex1;};CAG.Side.fromFakePolygon=function(polygon){if(polygon.vertices.length!=4){throw new Error("Assertion failed - 1");}
var pointsZeroZ=[];var indicesZeroZ=[];for(var i=0;i<4;i++){var pos=polygon.vertices[i].pos;if((pos.z>=-1.001)&&(pos.z<-0.999)){}else if((pos.z>=0.999)&&(pos.z<1.001)){}else{throw new Error("Assertion failed - 2");}
if(pos.z>0){pointsZeroZ.push(new CSG.Vector2D(pos.x,pos.y));indicesZeroZ.push(i);}}
if(pointsZeroZ.length!=2){throw new Error("Assertion failed - 3");}
var d=indicesZeroZ[1]-indicesZeroZ[0];var p1,p2;if(d==1){p1=pointsZeroZ[1];p2=pointsZeroZ[0];}else if(d==3){p1=pointsZeroZ[0];p2=pointsZeroZ[1];}else{throw new Error("Assertion failed - 4");}
var result=new CAG.Side(new CAG.Vertex(p1),new CAG.Vertex(p2));return result;};CAG.Side.prototype={toString:function(){return this.vertex0+" -> "+this.vertex1;},toPolygon3D:function(z0,z1){var vertices=[new CSG.Vertex(this.vertex0.pos.toVector3D(z0)),new CSG.Vertex(this.vertex1.pos.toVector3D(z0)),new CSG.Vertex(this.vertex1.pos.toVector3D(z1)),new CSG.Vertex(this.vertex0.pos.toVector3D(z1))];return new CSG.Polygon(vertices);},transform:function(matrix4x4){var newp1=this.vertex0.pos.transform(matrix4x4);var newp2=this.vertex1.pos.transform(matrix4x4);return new CAG.Side(new CAG.Vertex(newp1),new CAG.Vertex(newp2));},flipped:function(){return new CAG.Side(this.vertex1,this.vertex0);},direction:function(){return this.vertex1.pos.minus(this.vertex0.pos);},getTag:function(){var result=this.tag;if(!result){result=CSG.getTag();this.tag=result;}
return result;},lengthSquared:function(){var x=this.vertex1.pos.x-this.vertex0.pos.x,y=this.vertex1.pos.y-this.vertex0.pos.y;return x*x+y*y;},length:function(){return Math.sqrt(this.lengthSquared());}};CAG.fuzzyCAGFactory=function(){this.vertexfactory=new CSG.fuzzyFactory(2,1e-5);};CAG.fuzzyCAGFactory.prototype={getVertex:function(sourcevertex){var elements=[sourcevertex.pos._x,sourcevertex.pos._y];var result=this.vertexfactory.lookupOrCreate(elements,function(els){return sourcevertex;});return result;},getSide:function(sourceside){var vertex0=this.getVertex(sourceside.vertex0);var vertex1=this.getVertex(sourceside.vertex1);return new CAG.Side(vertex0,vertex1);},getCAG:function(sourcecag){var _this=this;var newsides=sourcecag.sides.map(function(side){return _this.getSide(side);});return CAG.fromSides(newsides);}};CSG.addTransformationMethodsToPrototype(CSG.prototype);CSG.addTransformationMethodsToPrototype(CSG.Vector2D.prototype);CSG.addTransformationMethodsToPrototype(CSG.Vector3D.prototype);CSG.addTransformationMethodsToPrototype(CSG.Vertex.prototype);CSG.addTransformationMethodsToPrototype(CSG.Plane.prototype);CSG.addTransformationMethodsToPrototype(CSG.Polygon.prototype);CSG.addTransformationMethodsToPrototype(CSG.Line3D.prototype);CSG.addTransformationMethodsToPrototype(CSG.Connector.prototype);CSG.addTransformationMethodsToPrototype(CSG.Path2D.prototype);CSG.addTransformationMethodsToPrototype(CSG.Line2D.prototype);CSG.addTransformationMethodsToPrototype(CAG.prototype);CSG.addTransformationMethodsToPrototype(CAG.Side.prototype);CSG.addTransformationMethodsToPrototype(CSG.OrthoNormalBasis.prototype);CSG.Polygon2D=function(points){var cag=CAG.fromPoints(points);this.sides=cag.sides;};CSG.Polygon2D.prototype=CAG.prototype;module.CSG=CSG;module.CAG=CAG;})(this);
